<!DOCTYPE html>
<html lang="en">

<head>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const link = document.getElementById("okcasella2");
            if (link) {
                link.addEventListener("click", function() {
                    this.textContent = "RISPOSTA ESATTA!";
                });
            }
        });
    </script><!--QUESTIONARIO CAMBIA TESTO CASELLA-->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const openPopupLink = document.getElementById("openPopupLink");
            const popupOverlay = document.getElementById("PopupOverlay");
            const pulsanteAccetta = document.getElementById("pulsante-accetta");

            const openPopupLinkGoHome = document.getElementById("openPopupLinkGoHome");
            const popupOverlay2 = document.getElementById("PopupOverlay2");
            const pulsanteAccetta2 = document.getElementById("pulsante-accetta2");

            openPopupLink.addEventListener("click", function(event) {
                event.preventDefault();
                popupOverlay.style.display = "flex";
            });

            pulsanteAccetta.addEventListener("click", function() {
                popupOverlay.style.display = "none";
            });

            openPopupLinkGoHome.addEventListener("click", function(event) {
                event.preventDefault();
                popupOverlay2.style.display = "flex";
            });

            pulsanteAccetta2.addEventListener("click", function() {
                window.location.href = "../";
            });
        });
    </script><!--POPUP LINK SCRIPT GO HOME-->
    <script src="/script/bootstrap.bundle.min.js"></script>
    <script src="/script/jquery-3.7.1.slim.min.js"></script>
    <script src="/script/jquery-scripts.js"></script>
	<!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-149953538-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-149953538-1');
    </script>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="Iosif Mihaescu">
    <title>SMÜZN</title>
    <!-- START Preload scripts -->
    <link rel="preload" href="/script/bootstrap.bundle.min.js" as="script">
    <link rel="preload" href="/script/jquery-3.7.1.slim.min.js" as="script">
    <link rel="preload" href="/script/jquery-scripts.js" as="script">
    <link rel="preload" href="/bootstrap.css" as="style">
    <link rel="preload" href="css.css" as="style">
    <link rel="preload" href="style.css" as="style">
    <link rel="preload" href="../../fonts/fonts.css" as="style">
    <!-- STOP Preload scripts -->
    <link rel="stylesheet" href="/bootstrap.css"  crossorigin="anonymous">
    <link rel="stylesheet" href="css.css">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="../../fonts/fonts.css">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <!-- Make IE recognize HTML5 tags. -->
    <!--[if IE]><script>/*@cc_on'abbr article aside audio canvas details figcaption figure footer header hgroup mark menu meter nav output progress section summary time video'.replace(/\w+/g,function(n){document.createElement(n)})@*/</script><![endif]-->

    <style>

        /* INIZIO schermata di caricamento */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100dvh;
            background-color: #FF0054;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }
        .loader {
            width: 50vw;
            height: auto;
            animation: spin 1.5s linear infinite;
            transition: scale 0.3s ease;
        }

        .corner-logo {
            position: absolute;
            width: auto;
            height: 10dvh;
            margin: calc(1vw + 1dvh);
            transition: scale 0.3s ease;
        }
        .top-left {
            top: 0;
            left: 0;
        }
        .top-right {
            top: 0;
            right: 0;
        }
        .bottom-left {
            bottom: 0;
            left: 0;
        }
        .bottom-right {
            bottom: 0;
            right: 0;
        }

        /* logo che gira al caricamento: */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* FINE schermata di caricamento*/

        /* INIZIO variazioni in base a dimensione viewport: */
        @media (max-width: 1200px) {

            .corner-logo {
                position: absolute;
                width: auto;
                height: 7dvh;
                transition: all 0.3s ease;
            }

            .top-left {
                top: 0;
                left: 0;
            }
            .top-right {
                top: 0;
                right: 0;
            }
            .bottom-left {
                bottom: 0;
                left: 0;
            }
            .bottom-right {
                bottom: 0;
                right: 0;
            }

        }

        @media (max-width: 968px) {

            .loader {
                width: 80vw;
                height: auto;
            }

        }
        /* FINE variazioni in base a dimensione viewport */

        /* Webkit-based browsers */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #FF0054;
            border: 1px solid white;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #e6004c; /* Slightly darker shade for hover effect */
        }

        ::-webkit-scrollbar-button {
            background: #ddd;
        }

        ::-webkit-scrollbar-button:hover {
            background: #bbb;
        }

        .link-testuale {
            color: var(--blu) !important;
            cursor: pointer !important;
        }

        .link-testuale:hover {
            color: var(--bgc) !important;
        }

        .btn, .section-notizie a *, .section-notizie a, .text1, .oggetto-cliccabile, .oggetto-cliccabile-tutto, .oggetto-cliccabile-tutto * {
            cursor: pointer !important;
        }


    </style>
</head>

<body>

<!--SCHERMATA DI CARICAMENTO, nascondi scrollbar -->
<script>
	// Nascondiamo la scrollbar
	const body = document.body;
	body.style.overflow = 'hidden';
</script>
<div id="loading-screen">
	<img src="/images/SVG/piu.svg" alt="Logo" class="corner-logo top-left">
	<img src="/images/SVG/piu.svg" alt="Logo" class="corner-logo top-right">
	<img src="/images/SVG/piu.svg" alt="Logo" class="corner-logo bottom-left">
	<img src="/images/SVG/piu.svg" alt="Logo" class="corner-logo bottom-right">
	<img src="/images/SVG/smuzn_logo.svg" alt="Loading" class="loader">
</div>
<script>
	//        SCHERMATA DI CARICAMENTO VELOCE
	window.addEventListener('load', function() {
		const loadingScreen = document.getElementById('loading-screen');
		loadingScreen.style.opacity = '0';
		setTimeout(function() {
			// Nascondiamo lo schermo di caricamento
			loadingScreen.style.opacity = '0';
			setTimeout(() => {
				loadingScreen.style.display = 'none';
				body.style.overflow = '';
			}, 500);
		});
	});
</script>
<!--SCHERMATA DI CARICAMENTO VELOCE-->

<!--PAGINA DI MANCATA COMPATIBILITÀ SCHERMO-->
<div class="pagina-disp-non-compatibile">
    <h1 class="pagina-disp-non-compatibile-text">DISPOSITIVO NON COMPATIBILE, ACCEDERE AL SITO DA UN PC</h1>
</div>

<!--PUBBLICITÀ-->
<div class="advertisement-left-container advertisement-containers">
    <!-- Questo elenco serve da modello. Lo script prende i GIF da qui. -->
    <a href=""><img class="advertisement" src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExenB3MGJkZXpjNzB3bnMzMHVpY2dlM2NpcWE4ZzN6aXA0c3JiaXB3diZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/l0HUi9wxwHRrYBKSY/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExdnpxY3lrNjR4MW9vbmY4bzZna3JpeHNnNDYyOWUwbGF3MmVyZmttOSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/8JZQ3hJJgNbW3g1q9q/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExc3d2cmF6dWQwcTBzYnBkeTduZHdzNjhxd2xsdGZrY3Q3ejI3NWdrYiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/GDlkBxUpzwiw2eyzOT/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExMmdmYmVnOG1kbHZqeTE5OWk3aTg0OWNwdHNvOTlraHphZDViOWVzNCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/tkxrAhRVHygX02rwMi/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExOTdza2gzbWV0NHk1NmcxNXVpdjh0aHd0c28ybzQ0ZDY2cm41NTdiYyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/OFnGDUy70bWcLwNnop/giphy.gif" style="object-position: 51% 100%;"></a>
    <a href=""><img class="advertisement" src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExN2FlMTQ4dXA0Y3ZubTcyaGMxMnJmaXN6OWt1bXdmdXJsMzc3bGNtNyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/SShkiplaF5fAYuVtVQ/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExaGQ0ejRqbWlvM3ZlOXZ6empmcnk0NGVmeTF2MHRwcHVmOTM1d2ttdCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/gLbubpq4LwZNIBIzQ3/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExd2F5eGRtNmNkNWtlMmswcGtnaHU1em5meDliYmN5d2M1MTdmdzltMiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/sG5K43XHNMkelkX65R/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExdGQ2NGZ2NW04cXZld202MWJ2b3VlZ2htYzQzZjcxODRhemw2cnJweCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/RMAXphSp1DoHEoIUBw/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExbjE5bGNwMGN5ZGl1YndybGtmZ3UyZmQ2eTJvMHo5ZWEyYnhpem9qdiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/iF1p3nEoZhSfFJYjBg/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExZzc2dXAzcHh5dmRrbjQ0anh4Y3A1ZGJ4c2ZubjJxZzVrbDNldDJ6dSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/OBzyzCJ5PqTYsDny8i/giphy.gif" style="object-position: 45% 100%;"></a>
    <a href=""><img class="advertisement" src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZDA5M2c3MDdwbmdkM2RmY2hweGV5ZXdmMjE1eTV5ejA2d2F6YXAyaCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/TsIdKpIYnEQMo2ZpAC/giphy.gif"></a>
    <a href=""><img class="advertisement" src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExMTJ0ZTNvazI5MHVxOXpvbnFnZmR0Y3Qxc3NhbWRlaXRic3lvbGtxeiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/fYGUuAE9YGJQ0QoCNX/giphy.gif"></a>
</div>

<div class="advertisement-right-container advertisement-containers">
    <!-- Anche questo è un modello. Può essere identico a quello di sinistra. -->
</div>



<div class="smuzn-webpage">



    <button id="scrollToTopBtn" title="Torna in cima" class="oggetto-cliccabile"></button>

    <!-- Popup Overlay -->
    <div id="PopupOverlay" class="popup-overlay">
        <div class="popup-content">
            <!-- Stato Iniziale del Popup -->
            <div id="initialConsent">
                <h2 class="popup-title">Abbiamo rimosso questo contenuto perchè non rispetta le nostre norme/viola le linee guida dello stato Italiano</h2>
                <div class="popup-buttons">
                    <button id="pulsante-accetta" class="btn btn-accetta">OK</button>
                </div>
                <p class="popup-details-text">
                </p>
            </div>
        </div>
    </div>
    <!-- Secondo Popup Overlay Go HOME-->
    <div id="PopupOverlay2" class="popup-overlay">
        <div class="popup-content">
            <div id="initialConsent2">
                <h2 class="popup-title">Non ci sono dati disponibili a riguardo…</h2>
                <div class="popup-buttons">
                    <button id="pulsante-accetta2" class="btn btn-accetta">chiudi</button>
                </div>
                <p class="popup-details-text"></p>
            </div>
        </div>
    </div>

    <!-- ======== INIZIO STRUTTURA POPUP VIDEO (Corretta) ======== -->
    <div id="video-modal-overlay" class="video-modal-overlay">
        <div class="video-modal-container">
            <!-- Pulsante di chiusura -->
            <button id="video-modal-close" class="video-modal-close oggetto-cliccabile-tutto" aria-label="Chiudi popup">×</button>

            <!-- Titolo del video -->
            <h2 id="video-modal-title" class="video-modal-title">Titolo del Video Qui</h2>

            <!-- Wrapper per immagine e pulsante play -->
            <div class="video-preview-wrapper">
                <!-- IMMAGINE E PULSANTE ORA SONO FRATELLI, DIRETTAMENTE DENTRO IL WRAPPER -->
                <img id="video-modal-image" src="" alt="Anteprima video" class="video-preview-image oggetto-cliccabile-tutto">
                <a id="video-modal-play-link" href="#" target="_blank" rel="noopener noreferrer" class="video-play-button oggetto-cliccabile-tutto" aria-label="Guarda il video">
                    <!-- Icona Play (triangolo) in SVG -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="40" height="40" fill="white">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                </a>
            </div>
        </div>
    </div>
    <!-- ======== FINE STRUTTURA POPUP VIDEO ======== -->

    <!-- ======== INIZIO BARRA DI PROSEGUIMENTO LETTURA ======== -->
    <div id="reading-progress-bar"></div>
    <!-- ======== FINE BARRA DI PROSEGUIMENTO LETTURA ======== -->



    <div class="webpage">
        <section class="pages">
            <div class="section1-container">
                <div class="section1">
    <!--                        <a href="/notizie" class="text1 text4">Smüzn</a>-->
                        <div class="box1">
                            <div class="box1-2">
                                <a href="/notizie" class="text1 text4">Smüzn</a>
                                <div class="item animated-vertical-text1">
                                    <div id="animated-text-strip">
                                        <span class="marquee">LA TUA FONTE DI NOTIZIE NUMERO 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
                                        <span class="marquee">LA TUA FONTE DI NOTIZIE NUMERO 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
                                        <span class="marquee">LA TUA FONTE DI NOTIZIE NUMERO 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
                                        <span class="marquee">LA TUA FONTE DI NOTIZIE NUMERO 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                </div>
            </div>
            <div class="header-placeholder"></div>

<!--            <section class="section3-2" id="section3-2">-->
<!--                <section class="box-section-name">-->
<!--                    <h1 class="year-text">Principali</h1>-->
<!--                </section>-->
<!--            </section>-->

            <div class="titolo-articolo-box">
                <h1 class="titolo-articolo">
                    Le Grandi Corporation Cercano di Controllare la Narrativa su Luigi
                </h1>
            </div>







            <div class="linea-separatore"></div>

            <div class="sezione1-articolo sezioni-articolo" id="sezione1-articolo">
                <div class="immagine-principale-bordo">
                        <img class="immagine-principale" src="https://m.media-amazon.com/images/S/pv-target-images/1994ff7791f1725ccae6afe887f255d749f1c3b45336ac6884aa195646490970._SX1080_FMjpg_.jpg">
                </div>
                <div class="immagine-principale-bordo-sopra">
                    <img src="/images/SVG/piu-red.svg" alt="Logo" class="news-card-plus-top-left">
                    <img src="/images/SVG/piu-red.svg" alt="Logo" class="news-card-plus-bottom-right">
                </div>
                <div class="testo-articolo-box">
                    <div class="testo-articolo-sub-box">

                        <p class="testo-articolo">
                            <span class="spazio-per-testo-fix-foto"></span>
                            <span class="capital-letter">Q</span>uasi
                                quattro mesi dopo l'omicidio di Brian Thompson, amministratore delegato di UnitedHealthcare, il caso continua a dominare il dibattito pubblico americano, trasformandosi in un potente simbolo delle contraddizioni del sistema sanitario a scopo di lucro.
                                Luigi Mangione, il presunto assassino, è diventato una figura iconica per milioni di cittadini che vedono nel suo gesto - seppur estremo - l'ultima disperata risposta a un sistema che privilegia i profitti delle corporation sulla salute delle persone.
                            <span class="oggetti-in-fila">
							<a href="" class="link-e-contenitore-immagine-advert-centrale"><img class="spazio-per-testo-con-oggetto-centro oggetto-cliccabile" style="margin-right: 2vmin;"></a>
							<a href="" class="link-e-contenitore-immagine-advert-centrale"><img class="spazio-per-testo-con-oggetto-centro oggetto-cliccabile" style="margin-left: 2vmin;"></a>
							</span>
                                L'ondata di sostegno popolare per Mangione si è manifestata attraverso una miriade di espressioni creative: murales nelle grandi città, meme virali sui social network, canzoni e persino merchandising. Questo fenomeno, soprannominato "Luigi-mania", riflette la profonda frustrazione di un paese dove milioni di persone hanno subito rifiuti di copertura assicurativa, bollette mediche insostenibili e, nei casi più tragici, la perdita di familiari a causa della mancanza di cure accessibili.
                        </p>
                    </div>
                </div>
            </div>

            <div class="sezione-notizie-interessanti">
                <a href="#" class="link-news news-windows news-window-1 oggetto-cliccabile-tutto">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-top-left">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-bottom-right">
                    <section class="news-windows-box news-windows-box-info"
                             data-title="Loading..."
                             data-news=""
                             data-year="">
                        <img src="https://via.placeholder.com/400x200.png?text=Loading..." alt="Loading news..." class="news-imgs">
                    </section>
                    <section class="news-card-text-box">
                        <h1 class="text-news-right">Loading title...<span class="text-news-bottom">Loading date...</span></h1>
                    </section>
                </a>
                <a href="#" class="link-news news-windows news-window-2 oggetto-cliccabile-tutto">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-top-left">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-bottom-right">
                    <section class="news-windows-box news-windows-box-info"
                             data-title="Loading..."
                             data-news=""
                             data-year="">
                        <img src="https://via.placeholder.com/400x200.png?text=Loading..." alt="Loading news..." class="news-imgs">
                    </section>
                    <section class="news-card-text-box">
                        <h1 class="text-news-right">Loading title...<span class="text-news-bottom">Loading date...</span></h1>
                    </section>
                </a>
            </div>

            <div class="sezione2-articolo sezioni-articolo">
                <div class="testo-articolo-box">
                    <div class="testo-articolo-sub-box">
                        <p class="testo-articolo">
                                Tuttavia, invece di cogliere l'occasione per riflettere sulle critiche al sistema, le grandi corporation e i media mainstream hanno risposto
                                con una strategia articolata di censura, manipolazione dell'informazione e repressione del dissenso.
                                Piattaforme come Reddit e TikTok hanno implementato politiche di moderazione particolarmente aggressive verso qualsiasi contenuto legato a Mangione. Su Reddit, semplici menzioni del nome "Luigi" - anche in contesti completamente estranei al caso, come discussioni sul personaggio dei videogiochi o riferimenti musicali - sono state automaticamente contrassegnate come "incitamento alla violenza". Interi subreddit dedicati al caso sono stati chiusi uno dopo l'altro, mentre post che esaltano figure conservatrici coinvolte in episodi di violenza rimangono online senza problemi.
                            <span class="oggetti-in-fila">
							<a href="" class="link-e-contenitore-immagine-advert-centrale"><img class="spazio-per-testo-con-oggetto-centro oggetto-cliccabile" style="margin-right: 2vmin;"></a>
							<a href="" class="link-e-contenitore-immagine-advert-centrale"><img class="spazio-per-testo-con-oggetto-centro oggetto-cliccabile" style="margin-left: 2vmin;"></a>
							</span>
                                Questa disparità di trattamento rivela un chiaro doppio standard: la violenza è tollerata quando si allinea agli interessi del potere, ma repressa quando diventa uno strumento di protesta contro di esso. UnitedHealthcare, dal canto suo, ha risposto alle critiche con metodi intimidatori. L'azienda ha ingaggiato lo studio legale Clare Locke - noto per aver difeso Dominion Voting Systems durante le polemiche elettorali del 2020 - per minacciare azioni legali contro chiunque osi denunciare le sue pratiche. Un caso emblematico è quello della chirurga Elisabeth Potter, che su Instagram ha raccontato come UnitedHealthcare abbia negato una copertura essenziale a una paziente già sul tavolo operatorio, mettendone a rischio la vita. Invece di affrontare il problema, l'azienda ha preteso la rimozione dei post e una ritrattazione pubblica, dimostrando ancora una volta la sua priorità: proteggere l'immagine aziendale, non i pazienti.
                        </p>
                    </div>
                </div>
            </div>

            <div class="sezione-notizie-interessanti">
                <a href="#" class="link-news news-windows news-window-1 oggetto-cliccabile-tutto">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-top-left">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-bottom-right">
                    <section class="news-windows-box news-windows-box-info"
                             data-title="Loading..."
                             data-news=""
                             data-year="">
                        <img src="https://via.placeholder.com/400x200.png?text=Loading..." alt="Loading news..." class="news-imgs">
                    </section>
                    <section class="news-card-text-box">
                        <h1 class="text-news-right">Loading title...<span class="text-news-bottom">Loading date...</span></h1>
                    </section>
                </a>
                <a href="#" class="link-news news-windows news-window-2 oggetto-cliccabile-tutto">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-top-left">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-bottom-right">
                    <section class="news-windows-box news-windows-box-info"
                             data-title="Loading..."
                             data-news=""
                             data-year="">
                        <img src="https://via.placeholder.com/400x200.png?text=Loading..." alt="Loading news..." class="news-imgs">
                    </section>
                    <section class="news-card-text-box">
                        <h1 class="text-news-right">Loading title...<span class="text-news-bottom">Loading date...</span></h1>
                    </section>
                </a>
            </div>

            <div class="sezione2-1-articolo sezioni-articolo">
                <div class="testo-articolo-box">
                    <div class="testo-articolo-sub-box">
                        <p class="testo-articolo">
                                I media tradizionali hanno svolto un ruolo cruciale nel distorcere la narrativa. Il New York Times, ad esempio, ha scelto di non pubblicare il cosiddetto "manifesto" di Mangione, un documento che conteneva critiche dettagliate al sistema sanitario americano, con argomentazioni supportate da dati (come il fatto che gli Stati Uniti spendono più di ogni altro paese per la sanità, ma hanno un'aspettativa di vita inferiore a nazioni come Cuba o Costa Rica). Invece di informare il pubblico, il Times ha preferito proteggere gli interessi dei suoi inserzionisti - tra cui molte aziende farmaceutiche e assicurative - promuovendo articoli di opinione che dipingevano Thompson come un "self-made man" e Mangione come un criminale senza scrupoli. Bret Stephens, editorialista del giornale, è arrivato a paragonare Mangione a Raskolnikov, il protagonista di “Crime and Punishment”, mentre Andrew Witty, CEO di UnitedHealth Group, ha potuto pubblicare un articolo non verificato in cui definiva Thompson un "pioniere compassionevole" della sanità.
                            <span class="oggetti-in-fila">
							<a href="" class="link-e-contenitore-immagine-advert-centrale"><img class="spazio-per-testo-con-oggetto-centro oggetto-cliccabile" style="margin-right: 2vmin;"></a>
							<a href="" class="link-e-contenitore-immagine-advert-centrale"><img class="spazio-per-testo-con-oggetto-centro oggetto-cliccabile" style="margin-left: 2vmin;"></a>
							</span>
                                Anche l'industria dell'intrattenimento ha contribuito alla campagna diffamatoria contro Mangione. Documentari come “Luigi Mangione: The Mind of a Killer” (prodotto da TMZ) lo hanno presentato come un assassino psicopatico ancor prima del processo, violando il principio della presunzione di innocenza. Allo stesso tempo, hanno completamente ignorato il contesto sociale che ha portato al crimine: gli algoritmi di UnitedHealthcare che rifiutano automaticamente migliaia di richieste di copertura, le storie di pazienti lasciati morire perché incapaci di pagare, e il sistema corrotto che permette a pochi di arricchirsi sulla sofferenza di molti.
                        </p>
                    </div>
                </div>
            </div>

            <div class="sezione-notizie-interessanti">
                <a href="#" class="link-news news-windows news-window-1 oggetto-cliccabile-tutto">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-top-left">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-bottom-right">
                    <section class="news-windows-box news-windows-box-info"
                             data-title="Loading..."
                             data-news=""
                             data-year="">
                        <img src="https://via.placeholder.com/400x200.png?text=Loading..." alt="Loading news..." class="news-imgs">
                    </section>
                    <section class="news-card-text-box">
                        <h1 class="text-news-right">Loading title...<span class="text-news-bottom">Loading date...</span></h1>
                    </section>
                </a>
                <a href="#" class="link-news news-windows news-window-2 oggetto-cliccabile-tutto">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-top-left">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-bottom-right">
                    <section class="news-windows-box news-windows-box-info"
                             data-title="Loading..."
                             data-news=""
                             data-year="">
                        <img src="https://via.placeholder.com/400x200.png?text=Loading..." alt="Loading news..." class="news-imgs">
                    </section>
                    <section class="news-card-text-box">
                        <h1 class="text-news-right">Loading title...<span class="text-news-bottom">Loading date...</span></h1>
                    </section>
                </a>
            </div>

            <div class="sezione2-2-articolo sezioni-articolo">
                <div class="testo-articolo-box">
                    <div class="testo-articolo-sub-box">
                        <p class="testo-articolo">
                                Ironia della sorte, è stata una serie televisiva come “Law & Order” - solitamente schierata dalla parte dell'ordine costituito - a offrire una delle analisi più equilibrate del caso. In un episodio ispirato alla vicenda, la difesa del personaggio basato su Mangione ha sostenuto che l'omicidio era giustificato per salvare migliaia di vite minacciate dalle politiche assassine delle assicurazioni. Pur essendo una finzione, questo scenario ha il merito di aver portato sullo schermo una verità scomoda che i media mainstream si rifiutano di affrontare.
                            <span class="oggetti-in-fila">
							<a href="" class="link-e-contenitore-immagine-advert-centrale"><img class="spazio-per-testo-con-oggetto-centro oggetto-cliccabile" style="margin-right: 2vmin;"></a>
							<a href="" class="link-e-contenitore-immagine-advert-centrale"><img class="spazio-per-testo-con-oggetto-centro oggetto-cliccabile" style="margin-left: 2vmin;"></a>
							</span>
                                Il caso Mangione non è solo la storia di un omicidio, ma il sintomo di una malattia ben più profonda: un sistema sanitario che tratta la vita umana come una merce. Le reazioni delle corporation e dei media
                                rivelano la loro paura più grande: non un singolo attentatore, ma una rivolta popolare organizzata che possa smantellare il loro potere. Come dimostrato dalle campagne di Bernie Sanders per Medicare for All, ogni tentativo di riforma radicale viene sistematicamente ostacolato dall'élite economica e dai suoi alleati mediatici. Oggi, la stessa macchina del fango viene usata contro Mangione e i suoi sostenitori, nel tentativo di trasformare una legittima protesta sociale in una patologica celebrazione della violenza.
                        </p>
                            </div>
                </div>
            </div>

            <div class="sezione-notizie-interessanti">
                <a href="#" class="link-news news-windows news-window-1 oggetto-cliccabile-tutto">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-top-left">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-bottom-right">
                    <section class="news-windows-box news-windows-box-info"
                             data-title="Loading..."
                             data-news=""
                             data-year="">
                        <img src="https://via.placeholder.com/400x200.png?text=Loading..." alt="Loading news..." class="news-imgs">
                    </section>
                    <section class="news-card-text-box">
                        <h1 class="text-news-right">Loading title...<span class="text-news-bottom">Loading date...</span></h1>
                    </section>
                </a>
                <a href="#" class="link-news news-windows news-window-2 oggetto-cliccabile-tutto">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-top-left">
                    <img src="/images/SVG/piu-red.svg" alt="Decoration" class="news-card-plus-bottom-right">
                    <section class="news-windows-box news-windows-box-info"
                             data-title="Loading..."
                             data-news=""
                             data-year="">
                        <img src="https://via.placeholder.com/400x200.png?text=Loading..." alt="Loading news..." class="news-imgs">
                    </section>
                    <section class="news-card-text-box">
                        <h1 class="text-news-right">Loading title...<span class="text-news-bottom">Loading date...</span></h1>
                    </section>
                </a>
            </div>





            <div class="sezione3-articolo sezioni-articolo">
                <div class="testo-articolo-box">
                    <div class="testo-articolo-sub-box" id="reading-progress-container">
                        <p class="testo-articolo">
                            Tuttavia, la rabbia verso un sistema ingiusto non può essere zittita a colpi di censura o propaganda. Perché, come ricorda il documento, i veri killer non sono quelli che impugnano una pistola, ma quelli che, seduti in consiglio d'amministrazione, firmano politiche che condannano migliaia di persone a morti evitabili. E finché questa verità rimarrà sepolta sotto tonnellate di menzogne, il caso Mangione continuerà a essere un grido di battaglia per chi crede che la salute non debba essere un privilegio, ma un diritto.
                        </p>
                    </div>
                </div>
            </div>


<!--            <section class="section3" id="section3">-->
<!--                    <section class="box-section-name">-->
<!--                        <h1 class="year-text">Dal Mondo</h1>-->
<!--                    </section>-->
<!--            </section>-->

            <footer class="footer">
                <div class="box5">
                    <a href="/notizie/contatti" class="text4 oggetto-cliccabile">clicca qui per i contatti</a>
                </div>
                <div class="box5-2">
                    <img class="logo-endpage no-drag" src="/images/SVG/smuzn-endpage.svg" alt="SMÜZN">
                </div>

            </footer>
        </section>
    </div>





    <!-- QUESTA È LA SCHERMATA DEL DINOSAURO CHE APPARE -->
    <div id="t-rex-overlay" class="offline">
        <div id="main-frame-error" class="interstitial-wrapper">
            <div id="main-content">
                <div class="icon icon-offline"></div>
                <div id="main-message">
                    <!-- TESTO PERSONALIZZATO -->
                    <h1 class="testo-t-rex">LA CONNESSIONE È STATA INTERROTTA DALLO STATO</h1>
                    <p class="testo-t-rex">Prova a:</p>
                    <ul class="testo-t-rex">
                        <li class="testo-t-rex">Controllare i cavi di rete, il modem e il router</li>
                        <li class="testo-t-rex">Riconnessione alla rete Wi-Fi</li>
                    </ul>
                    <!-- CODICE ERRORE PERSONALIZZATO -->
                    <div class="error-code testo-t-rex-errore">ERR_INTERNET_DISCONNECTED</div>
                </div>
            </div>
        </div>

        <!-- Contenitore del gioco del T-Rex -->
        <div class="runner-container">
            <canvas class="runner-canvas" width="600" height="150"></canvas>
        </div>

        <!-- Risorse del gioco (immagini e suoni) -->
        <div id="offline-resources">
            <img id="1x-obstacle-large" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAyCAMAAACJUtIoAAAACVBMVEX////39/dTU1OabbyfAAAAAXRSTlMAQObYZgAAAXhJREFUeF7t2NGqAjEMANGM///RlwvaYQndULuFPJgHUYaEI6IPhgNAOA8HZ+3U6384F5y1U6YzAZTWG+dZamnFEstBFtCKJZSHWMADLJ18z+JqpQeLdKoDC8siC5iFCQs4znIxB5B1t6F3lQWkL4N0JsF+u6GXJdbI+FKW+yWr3lhgCZ2VSag3Nlk/FnRkIRbasLCO0oulikMsvmGpeiGLZ1jOMgtIP5bODivYYUXEIVbwFCt4khVssRgsgidZwQaLd2A8m7MYLGTl4KeQQs2y4kMAMGGlmQViDIb5O6xZnnLD485dIBzqDSE1yyFdL4Iqu4XJqUUWl/NVAFSZq1P6a5aqbAUM2epQbBioWflUBABiUyhYyZoCBev8XyMAObDNOhOAfiyxmHU0YNlldGAphGjFCjA3YkUn1o/1Y3EkZFZ5isCC6NUgwDBn1RuXH96doNfAhDXfsIyJ2AnolcCVhay0kcYbW0HvCO8OwIcJ3GzkORpkFuUP/1Ec8FW1qJkAAAAASUVORK5CYII=">
            <img id="1x-obstacle-small" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGYAAAAjCAMAAABRlI+PAAAADFBMVEX////////39/dTU1PhglcSAAAAAXRSTlMAQObYZgAAAPNJREFUeF7tlkEKwzAMBLXr//+5iQhU7gRRQkyhZI+DhwH74jhmO+oIJBVwURljuAXagG5QqkSgBLqg3JnxJ1Cb8SmQ3o6gpO85owGlOB4m2BNKJ11BSd01owGlOHkcIAuHkz6UNpPKgozPM54dADHjJuNhZiJxdQCQgZJeBczgCAAy3yhPJvcnmdC9mZwBIsQMFV5AkzHBNknFgcKM+oyDIFcfCAoy03m+jSMIcmoVZkKqSjr1fghyahRmoKRUHYLiSI1SMlCq5CDgX6BXmKkfn+oQ0KEyyrzoy8GbXJ9xrM/YjhUZgl9nnsyTCe9rgSRdV15CwRcIEu8GGQAAAABJRU5ErkJggg==">
            <img id="1x-cloud" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAOCAQAAAD6HOaKAAAAU0lEQVR4XrWSsQkAQAgD3X9El/ELixQpJHCfdApnUCtXz7o49cgagaGPaq4rIwAP9s/C7R7UX3inJ0BDb6qWDC7ScOR/QWjRlFizuPwLtTLj+qkH6DjD2wLtikUAAAAASUVORK5CYII=">
            <img id="1x-text" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAL8AAAAYAQMAAACRPb4TAAAABlBMVEX///9TU1NYzE1OAAAAAXRSTlMAQObYZgAAAPBJREFUeF6lzzFqwzAUx+F/0eBN7wIBXcGjQk3V2/QAHZohEAfv7nU6lUKGbD7DAxe62Soe6lAjtRLGiQOGQh8aHnyCHw+ZSD4dmUPntqpaO0yzIzo5Y46d86a5hAeSemV0IspaNzo9Q11gkz6ZCqvuGkQ/fJnWZt60/Rzs8IHWplt1Bcmb9Hmj+TmfNbqCDqV/CbCfwaMgUSb6F4p9dQmZak9Doo6Wd0qu3TL8YxRDAczwDIgeUoIcqF8GDdzm+GYwACnjiwuP3/8ONY/g8wj0GgLybsy+T43QB8gug+ZgPMGNjY0NVITzHbgHudBYgh9W5adHzknZVQAAAABJRU5ErkJggg==">
            <img id="1x-horizon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLAAAAAMAgMAAAAPCKxBAAAABlBMVEX///9TU1NYzE1OAAAAAXRSTlMAQObYZgAAALJJREFUeF7t1EEKAyEMhtEvMNm7sPfJEVyY+1+ltLgYAsrQCtWhbxEhQvgxIJtSZypxa/WGshgzKdbq/UihMFMlt3o/CspEYoihIMaAb6mCvM6C+BTAeyo+wN4yykV/6pVfkdLpVyI1hh7GJ6QunUoLEQlQglNP2nkQkeF8+ei9cLxMue1qxVRfk1Ej0s6AEGWfVOk0QUtnK5Xo0Lac6wpdtnQqB6VxomPaz+dgF1PaqqmeWJlz1jYUaSIAAAAASUVORK5CYII=">
            <img id="1x-trex" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQgAAAAvAgMAAABiRrxWAAAADFBMVEX///9TU1P39/f///+TS9URAAAAAXRSTlMAQObYZgAAAPpJREFUeF7d0jFKRkEMhdGLMM307itNLALyVmHvJuzTDMjdn72E95PGFEZSmeoU4YMMgxhskvQec8YSVFX1NhGcS5ywtbmC8khcZeKq+ZWJ4F8Sr2+ZCErjkJFEfcjAc/6/BMlfcz6xHdhRthYzIZhIHMcTVY1scUUiAphK8CMSPUbieTBhvD9Lj0vyV4wklEGzHpciKGOJoBp7XDcFs4kWxxM7Ey3iZ8JbzASAvMS7XLOJHTTvEkEZSeQl7DMuwVyCasqK5+XzQRYLUJlMbPXjFcn3m8eKBSjWZMJwvGIOvViAzCbUj1VEDoqFOEQGE3SyInJQLOQMJL4B7enP1UbLXJQAAAAASUVORK5CYII=">
            <img id="1x-restart" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAgCAQAAADQmBIFAAAAZklEQVR4Xu3WMQoAIAxDUe/Y+58jYwV1CwQJWQT5o/DAoaWjV2i/LRym/A5FjEsR41LPQchByEHwIVAEC4gZpghmSDP8egXpr/hQZaAKQFQe+pBOQAblDC336qrlPpSg0MEjInbWTLFFmwc8TpTAAAAAAElFTkSuQmCC">
            <img id="2x-obstacle-large" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAABkBAMAAADOLxDzAAAACVBMVEX///9TU1P39/ea77PDAAAAAXRSTlMAQObYZgAAAa9JREFUeF7t1lFqhEAQBuG+wl6h7n/IEEgKlma2R8Vk1O4HWSh++Xzb8AKA8E4IXrlYnsXr+zgh1OdifZbBdFIApdWiWShtVhmQ+jAWMLFollCOsTzgxiyd7GcR01/YLOZf1SwsN2EBozBgAU9l4TAHkDWzCNjKApZlybO4z+GtFwu9bGKZl2TJSyxDxaoX8yyha7LGZRDqxR+ymtUsaNaWhTM+s5rl05tjNUsVz2Kxi6XqhSy4NcvbzgLSnzzvjqzgCCsiHsXSdZwVPIAVHGIhi+ABrOAAi5+Avy7HQhaycpAVpDDBsuKDAOBCrHzjQHgYhl9YsHxf+vRrsQxjVVAsDNMsF6uydBUhq+wWBq/ayCKWZekqA6DKPPEq/ZMsYllWdgGDoMdaLAzMsFwszgoAi1pDxUrWFKhZLlZnpXIkAORAs7YEoFmzQSxmt2NWs+xOP7GapRCiZjUrwFyymhX/xmpWs5rVrGZxQphmsT6LAAsvdgcBhmmWi9VZvN7+x+4K2WtgwBosFmZZvIh9IXsl8M5C1mCxLsvTfizoxfDTAfgdAIPFlVhxRqgHlrVZX9y44aEEvVqmAAAAAElFTkSuQmCC">
            <img id="2x-obstacle-small" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMwAAABGBAMAAAByJ2Z/AAAADFBMVEX///9TU1P39/f///+TS9URAAAAAXRSTlMAQObYZgAAARZJREFUeF7t2NEJwzAQg2GtcCtoBe2/W6k5aK8qLgR6ToL9KPzzgR+NPCRRjg2ScjiQ9DKMCE4HRYQOJB2MJyXyQWPQgeSCDD8HnYHh10F6NbJk9KyMwpJ+hkEfnoSyGX1NUmAOqVjSz4zrNgwhm9FbMmEyuS7DpQw/Gf5kOGEYXMgwWBobnGHQmZKsYuyKDcZk8gdmM5uJMzKbgS7I5KENgJzxxN95PUMfAKi8gCXO6BQM4cM4ysEZwplyfxFDErAhmWniDKT3pJEpD2RDMpPEGUt6mOIQ1XFGmiXOZNLIgKUpgzH4lTgDtDIgmY0NznhSnWhk/v2ZkuONGOI2DEn0MNf7ttvMZjazmc2AJDkdJOlQ0sk8AC45t4r28J0GAAAAAElFTkSuQmCC">
            <img id="2x-cloud" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFwAAAAcAgMAAACR2TCnAAAABlBMVEUAAADa2to4qB92AAAAAXRSTlMAQObYZgAAAFFJREFUeF6VzTEKAFEIxNA03m+a3P8q2wqi/E35BIdeGXq3q5hnrwBs7mC5vIZzu/nnqI319vRtqHB731blwSHjx+22+Rdn94rzQq0ugKPVlz5onyJcGdu0NgAAAABJRU5ErkJggg==">
            <img id="2x-text" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAX4AAAAwAQMAAAAsMYMXAAAABlBMVEX///9TU1NYzE1OAAAAAXRSTlMAQObYZgAAAPxJREFUeF7tk0FqBCEQRf/gwt14BK+RlV4p2Te0OUFfSZiLmFvUQvzpQgYbOqtA7FnkLz7FhydUlQUr8Ck2w3prjsXuVqMYFrEPVpw0AXgLWJO4bPTxhAiXqtzVbPbpEkCc5nG3GByLAKbwBQDbsBYJQGXTKYthJS8FogD6JOrOL/iiVvYqIN7hE3W/CC51oOjirwNsH+GDBcGwxIYFeh6p38ME4Ff6l6GoN63rTWtqovLMh7B7ngD0I/Fb1nQTxaDq/PBnMgEYFUC+BuDkPLsjwG2E1U0Bju1+nHt47hsqNkwA/KecJjiA8S97suYJgOEAfrwHvGM06eTvgW+oln6hOpuT1AAAAABJRU5ErkJggg==">
            <img id="2x-horizon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACWAAAAAYAQMAAABEalRSAAAABlBMVEX///9TU1NYzE1OAAAAAXRSTlMAQObYZgAAAOtJREFUeF7tljEKwzAMRb/J0CWgI/QKOYAh1+pUcjQfpUfw2MFEHVyDQSQmQUNM9AYNcobnh4egU+YVqhAvZSpgsfolPnSv5d0nz3vHslgUdK81RLzyvHcsi+WBNxQh4Ln8pw4Wi7skAg9mXgHMrEACXJnbHIllsbqGAtwXhnYswzFzwPWxWEPc2CexoobkHM4ZpD6s2loWiyIEEwCChIomMiMEHqgP573C9eHkc5VLWh3XsljnGVoLWVl+31bp38piTVVuihtPOAm9kcRLbrFjEvqwamtZLK5eI8sSan9rXEK0LcNFrY5oWawf59S7YSRD7eMAAAAASUVORK5CYII=">
            <img id="2x-trex" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhAAAABeAgMAAAAPo8UvAAAADFBMVEX///9TU1P39/f///+TS9URAAAAAXRSTlMAQObYZgAAASdJREFUeF7t1qFOBEEQRdEyGP7vGQy/hsHc/0MPSe8ylU2vKEIqqQnviRZXdI7pyUQuONda901FGAG6j8aa+6mDEUboHP01sk5EHHWEjt/UY0dk/U+Ir/cdkXUEovV1GFF/HQMR/mLWEUYYYQRrf65XRhgB2595Y80lYRjCCG7AV/IZ0FdDabgDhiKMgE+tAX01ES+ajDBCADpHZw0tRdaZCCNEGhCdNSSlQTEVYUROQGeNxxoxH2EErXU+wohdQXONqyBorDsixiB2Be01JiOM2BXQX1MRUxFGpAL6aypiMsIIJCFBtSK98fFYKd6wFDEbYUQgEYh6hTSkonbDDTAdYQTrKNd9QPWGUFwAYYRYR7U+XemGfB0ajTACWEe1Pl3thtxMhBHfOCEbEnR2KZcAAAAASUVORK5CYII=">
            <img id="2x-restart" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABAAgMAAADE0Nm5AAAACVBMVEX////39/dTU1OabbyfAAAAAXRSTlMAQObYZgAAAGNJREFUeF7d1CEOwDAMQ9GS3q/ExPcz8Sm3gYBWVRo0afvwSQl0ax1To22JntKWupfGjriSXiLViCXCmXBHCykJTxaYEeIQGcVrHYklcoX8YYpSUggzcpBTiv5JtQWorUltmS6s4ZKtz2GgjAAAAABJRU5ErkJggg==">
        </div>
    </div>






    <script>
        // Copyright (c) 2014 The Chromium Authors. All rights reserved.
        // Use of this source code is governed by a BSD-style license that can be
        // found in the LICENSE file.
        (function() {
            'use strict';
            function Runner(outerContainerId, opt_config) {
                if (Runner.instance_) { return Runner.instance_; }
                Runner.instance_ = this;
                this.outerContainerEl = document.querySelector(outerContainerId);
                this.containerEl = null;
                this.detailsButton = this.outerContainerEl.querySelector('#details-button');
                this.config = opt_config || Runner.config;
                this.dimensions = Runner.defaultDimensions;
                this.canvas = null;
                this.canvasCtx = null;
                this.tRex = null;
                this.distanceMeter = null;
                this.distanceRan = 0;
                this.highestScore = 0;
                this.time = 0;
                this.runningTime = 0;
                this.msPerFrame = 1000 / FPS;
                this.currentSpeed = this.config.SPEED;
                this.obstacles = [];
                this.started = false;
                this.activated = false;
                this.crashed = false;
                this.paused = false;
                this.resizeTimerId_ = null;
                this.playCount = 0;
                this.audioBuffer = null;
                this.soundFx = {};
                this.audioContext = null;
                this.images = {};
                this.imagesLoaded = 0;
                this.loadImages();
            }
            window['Runner'] = Runner;
            var DEFAULT_WIDTH = 600;
            var FPS = 60;
            var IS_HIDPI = window.devicePixelRatio > 1;
            var IS_IOS = window.navigator.userAgent.indexOf('UIWebViewForStaticFileContent') > -1;
            var IS_MOBILE = window.navigator.userAgent.indexOf('Mobi') > -1 || IS_IOS;
            var IS_TOUCH_ENABLED = 'ontouchstart' in window;
            Runner.config = {
                ACCELERATION: 0.001, BG_CLOUD_SPEED: 0.2, BOTTOM_PAD: 10, CLEAR_TIME: 3000,
                CLOUD_FREQUENCY: 0.5, GAMEOVER_CLEAR_TIME: 750, GAP_COEFFICIENT: 0.6,
                GRAVITY: 0.6, INITIAL_JUMP_VELOCITY: 12, MAX_CLOUDS: 6, MAX_OBSTACLE_LENGTH: 3,
                MAX_SPEED: 13, MIN_JUMP_HEIGHT: 35, MOBILE_SPEED_COEFFICIENT: 1.2,
                RESOURCE_TEMPLATE_ID: 'audio-resources', SPEED: 6, SPEED_DROP_COEFFICIENT: 3
            };
            Runner.defaultDimensions = { WIDTH: DEFAULT_WIDTH, HEIGHT: 150 };
            Runner.classes = {
                CANVAS: 'runner-canvas', CONTAINER: 'runner-container', CRASHED: 'crashed',
                ICON: 'icon-offline', TOUCH_CONTROLLER: 'controller'
            };
            Runner.imageSources = {
                LDPI: [
                    {name: 'CACTUS_LARGE', id: '1x-obstacle-large'}, {name: 'CACTUS_SMALL', id: '1x-obstacle-small'},
                    {name: 'CLOUD', id: '1x-cloud'}, {name: 'HORIZON', id: '1x-horizon'},
                    {name: 'RESTART', id: '1x-restart'}, {name: 'TEXT_SPRITE', id: '1x-text'},
                    {name: 'TREX', id: '1x-trex'}
                ],
                HDPI: [
                    {name: 'CACTUS_LARGE', id: '2x-obstacle-large'}, {name: 'CACTUS_SMALL', id: '2x-obstacle-small'},
                    {name: 'CLOUD', id: '2x-cloud'}, {name: 'HORIZON', id: '2x-horizon'},
                    {name: 'RESTART', id: '2x-restart'}, {name: 'TEXT_SPRITE', id: '2x-text'},
                    {name: 'TREX', id: '2x-trex'}
                ]
            };
            Runner.sounds = { BUTTON_PRESS: 'offline-sound-press', HIT: 'offline-sound-hit', SCORE: 'offline-sound-reached' };
            Runner.keycodes = { JUMP: {'38': 1, '32': 1}, DUCK: {'40': 1}, RESTART: {'13': 1} };
            Runner.events = {
                ANIM_END: 'webkitAnimationEnd', CLICK: 'click', KEYDOWN: 'keydown', KEYUP: 'keyup',
                MOUSEDOWN: 'mousedown', MOUSEUP: 'mouseup', RESIZE: 'resize', TOUCHEND: 'touchend',
                TOUCHSTART: 'touchstart', VISIBILITY: 'visibilitychange', BLUR: 'blur', FOCUS: 'focus', LOAD: 'load'
            };
            Runner.prototype = {
                updateConfigSetting: function(setting, value) {
                    if (setting in this.config && value != undefined) {
                        this.config[setting] = value;
                        switch (setting) {
                            case 'GRAVITY':
                            case 'MIN_JUMP_HEIGHT':
                            case 'SPEED_DROP_COEFFICIENT':
                                this.tRex.config[setting] = value;
                                break;
                            case 'INITIAL_JUMP_VELOCITY':
                                this.tRex.setJumpVelocity(value);
                                break;
                            case 'SPEED':
                                this.setSpeed(value);
                                break;
                        }
                    }
                },
                loadImages: function() {
                    var imageSources = IS_HIDPI ? Runner.imageSources.HDPI : Runner.imageSources.LDPI;
                    var numImages = imageSources.length;
                    for (var i = numImages - 1; i >= 0; i--) {
                        var imgSource = imageSources[i];
                        this.images[imgSource.name] = document.getElementById(imgSource.id);
                    }
                    this.init();
                },
                loadSounds: function() {
                    // Sounds disabled for this script
                },
                setSpeed: function(opt_speed) {
                    var speed = opt_speed || this.currentSpeed;
                    if (this.dimensions.WIDTH < DEFAULT_WIDTH) {
                        var mobileSpeed = speed * this.dimensions.WIDTH / DEFAULT_WIDTH * this.config.MOBILE_SPEED_COEFFICIENT;
                        this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;
                    } else if (opt_speed) {
                        this.currentSpeed = opt_speed;
                    }
                },
                init: function() {
                    this.adjustDimensions();
                    this.setSpeed();
                    this.containerEl = this.outerContainerEl.querySelector('.runner-container');
                    this.canvas = this.containerEl.querySelector('.runner-canvas');
                    this.canvasCtx = this.canvas.getContext('2d');
                    this.canvasCtx.fillStyle = '#f7f7f7';
                    this.canvasCtx.fill();
                    Runner.updateCanvasScaling(this.canvas);
                    this.horizon = new Horizon(this.canvas, this.images, this.dimensions, this.config.GAP_COEFFICIENT);
                    this.distanceMeter = new DistanceMeter(this.canvas, this.images.TEXT_SPRITE, this.dimensions.WIDTH);
                    this.tRex = new Trex(this.canvas, this.images.TREX);
                    this.outerContainerEl.appendChild(this.containerEl);
                    if (IS_MOBILE) {
                        this.createTouchController();
                    }
                    this.startListening();
                    this.update();
                    window.addEventListener(Runner.events.RESIZE, this.debounceResize.bind(this));
                },
                createTouchController: function() {
                    this.touchController = document.createElement('div');
                    this.touchController.className = Runner.classes.TOUCH_CONTROLLER;
                    this.outerContainerEl.appendChild(this.touchController);
                },
                debounceResize: function() {
                    if (!this.resizeTimerId_) {
                        this.resizeTimerId_ = setInterval(this.adjustDimensions.bind(this), 250);
                    }
                },
                adjustDimensions: function() {
                    clearInterval(this.resizeTimerId_);
                    this.resizeTimerId_ = null;
                    var boxStyles = window.getComputedStyle(this.outerContainerEl);
                    var padding = Number(boxStyles.paddingLeft.substr(0, boxStyles.paddingLeft.length - 2));
                    this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;
                    if (this.canvas) {
                        this.canvas.width = this.dimensions.WIDTH;
                        this.canvas.height = this.dimensions.HEIGHT;
                        Runner.updateCanvasScaling(this.canvas);
                        this.distanceMeter.calcXPos(this.dimensions.WIDTH);
                        this.clearCanvas();
                        this.horizon.update(0, 0, true);
                        this.tRex.update(0);
                        if (this.activated || this.crashed || this.paused) {
                            this.containerEl.style.width = this.dimensions.WIDTH + 'px';
                            this.distanceMeter.update(0, Math.ceil(this.distanceRan));
                            this.stop();
                        } else {
                            this.tRex.draw(0, 0);
                        }
                        if (this.crashed && this.gameOverPanel) {
                            this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);
                            this.gameOverPanel.draw();
                        }
                    }
                },
                playIntro: function() {
                    if (!this.started && !this.crashed) {
                        this.playingIntro = true;
                        this.tRex.playingIntro = true;
                        var keyframes = '@-webkit-keyframes intro { from { width:' + Trex.config.WIDTH + 'px } to { width: ' + this.dimensions.WIDTH + 'px }}';
                        document.styleSheets[0].insertRule(keyframes, 0);
                        this.containerEl.addEventListener(Runner.events.ANIM_END, this.startGame.bind(this));
                        this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';
                        this.containerEl.style.width = this.dimensions.WIDTH + 'px';
                        this.activated = true;
                        this.started = true;
                    } else if (this.crashed) {
                        this.restart();
                    }
                },
                startGame: function() {
                    this.runningTime = 0;
                    this.playingIntro = false;
                    this.tRex.playingIntro = false;
                    this.containerEl.style.webkitAnimation = '';
                    this.playCount++;
                    window.addEventListener(Runner.events.VISIBILITY, this.onVisibilityChange.bind(this));
                    window.addEventListener(Runner.events.BLUR, this.onVisibilityChange.bind(this));
                    window.addEventListener(Runner.events.FOCUS, this.onVisibilityChange.bind(this));
                },
                clearCanvas: function() {
                    this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH, this.dimensions.HEIGHT);
                },
                update: function() {
                    this.drawPending = false;
                    var now = getTimeStamp();
                    var deltaTime = now - (this.time || now);
                    this.time = now;
                    if (this.activated) {
                        this.clearCanvas();
                        if (this.tRex.jumping) {
                            this.tRex.updateJump(deltaTime, this.config);
                        }
                        this.runningTime += deltaTime;
                        var hasObstacles = this.runningTime > this.config.CLEAR_TIME;
                        if (this.tRex.jumpCount == 1 && !this.playingIntro) {
                            this.playIntro();
                        }
                        if (this.playingIntro) {
                            this.horizon.update(0, this.currentSpeed, hasObstacles);
                        } else {
                            deltaTime = !this.started ? 0 : deltaTime;
                            this.horizon.update(deltaTime, this.currentSpeed, hasObstacles);
                        }
                        var collision = hasObstacles && checkForCollision(this.horizon.obstacles[0], this.tRex);
                        if (!collision) {
                            this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;
                            if (this.currentSpeed < this.config.MAX_SPEED) {
                                this.currentSpeed += this.config.ACCELERATION;
                            }
                        } else {
                            this.gameOver();
                        }
                        this.distanceMeter.update(deltaTime, Math.ceil(this.distanceRan));
                    }
                    if (!this.crashed) {
                        this.tRex.update(deltaTime);
                        this.raq();
                    }
                },
                handleEvent: function(e) {
                    return (function(evtType, events) {
                        switch (evtType) {
                            case events.KEYDOWN:
                            case events.TOUCHSTART:
                            case events.MOUSEDOWN:
                                this.onKeyDown(e);
                                break;
                            case events.KEYUP:
                            case events.TOUCHEND:
                            case events.MOUSEUP:
                                this.onKeyUp(e);
                                break;
                        }
                    }.bind(this))(e.type, Runner.events);
                },
                startListening: function() {
                    document.addEventListener(Runner.events.KEYDOWN, this);
                    document.addEventListener(Runner.events.KEYUP, this);
                    if (IS_MOBILE) {
                        if (this.touchController) {
                            this.touchController.addEventListener(Runner.events.TOUCHSTART, this);
                            this.touchController.addEventListener(Runner.events.TOUCHEND, this);
                        }
                        this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);
                    } else {
                        document.addEventListener(Runner.events.MOUSEDOWN, this);
                        document.addEventListener(Runner.events.MOUSEUP, this);
                    }
                },
                stopListening: function() {
                    document.removeEventListener(Runner.events.KEYDOWN, this);
                    document.removeEventListener(Runner.events.KEYUP, this);
                    if (IS_MOBILE) {
                        if (this.touchController) {
                            this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);
                            this.touchController.removeEventListener(Runner.events.TOUCHEND, this);
                        }
                        this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);
                    } else {
                        document.removeEventListener(Runner.events.MOUSEDOWN, this);
                        document.removeEventListener(Runner.events.MOUSEUP, this);
                    }
                },
                onKeyDown: function(e) {
                    if (e.target != this.detailsButton) {
                        if (!this.crashed && (Runner.keycodes.JUMP[String(e.keyCode)] || e.type == Runner.events.TOUCHSTART)) {
                            if (!this.activated) {
                                this.loadSounds();
                                this.activated = true;
                            }
                            if (!this.tRex.jumping) {
                                this.tRex.startJump();
                            }
                        }
                        if (this.crashed && e.type == Runner.events.TOUCHSTART && e.currentTarget == this.containerEl) {
                            this.restart();
                        }
                    }
                    if (!this.crashed && Runner.keycodes.DUCK[e.keyCode]) {
                        e.preventDefault();
                        if (this.tRex.jumping) {
                            this.tRex.setSpeedDrop();
                        }
                    }
                },
                onKeyUp: function(e) {
                    var keyCode = String(e.keyCode);
                    var isjumpKey = Runner.keycodes.JUMP[keyCode] || e.type == Runner.events.TOUCHEND || e.type == Runner.events.MOUSEDOWN;
                    if (this.isRunning() && isjumpKey) {
                        this.tRex.endJump();
                    } else if (Runner.keycodes.DUCK[keyCode]) {
                        this.tRex.speedDrop = false;
                        this.tRex.setDuck(false);
                    } else if (this.crashed) {
                        var deltaTime = getTimeStamp() - this.time;
                        if (Runner.keycodes.RESTART[keyCode] || isjumpKey && (deltaTime >= this.config.GAMEOVER_CLEAR_TIME)) {
                            this.restart();
                        }
                    } else if (this.paused && isjumpKey) {
                        this.tRex.reset();
                        this.play();
                    }
                },
                raq: function() {
                    if (!this.drawPending) {
                        this.drawPending = true;
                        this.raqId = requestAnimationFrame(this.update.bind(this));
                    }
                },
                isRunning: function() { return !!this.raqId; },
                gameOver: function() {
                    this.stop();
                    this.crashed = true;
                    this.distanceMeter.acheivement = false;
                    this.tRex.update(100, Trex.status.CRASHED);
                    if (!this.gameOverPanel) {
                        this.gameOverPanel = new GameOverPanel(this.canvas, this.images.TEXT_SPRITE, this.images.RESTART, this.dimensions);
                    }
                    this.gameOverPanel.draw();
                    if (this.distanceRan > this.highestScore) {
                        this.highestScore = Math.ceil(this.distanceRan);
                        this.distanceMeter.setHighScore(this.highestScore);
                    }
                    this.time = getTimeStamp();
                },
                stop: function() {
                    this.activated = false;
                    this.paused = true;
                    cancelAnimationFrame(this.raqId);
                    this.raqId = 0;
                },
                play: function() {
                    if (!this.crashed) {
                        this.activated = true;
                        this.paused = false;
                        this.tRex.update(0, Trex.status.RUNNING);
                        this.time = getTimeStamp();
                        this.update();
                    }
                },
                restart: function() {
                    if (!this.raqId) {
                        this.playCount++;
                        this.runningTime = 0;
                        this.activated = true;
                        this.crashed = false;
                        this.distanceRan = 0;
                        this.setSpeed(this.config.SPEED);
                        this.time = getTimeStamp();
                        this.clearCanvas();
                        this.distanceMeter.reset();
                        this.horizon.reset();
                        this.tRex.reset();
                        this.update();
                    }
                },
                onVisibilityChange: function(e) {
                    if (document.hidden || document.webkitHidden || e.type == 'blur' || document.visibilityState != 'visible') {
                        this.stop();
                    } else {
                        this.play();
                    }
                },
                playSound: function(soundBuffer) {
                    // Sounds disabled.
                }
            };
            Runner.updateCanvasScaling = function(canvas, opt_width, opt_height) {
                var context = canvas.getContext('2d');
                var devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;
                var backingStoreRatio = Math.floor(context.webkitBackingStorePixelRatio) || 1;
                var ratio = devicePixelRatio / backingStoreRatio;
                if (devicePixelRatio !== backingStoreRatio) {
                    var oldWidth = opt_width || canvas.width;
                    var oldHeight = opt_height || canvas.height;
                    canvas.width = oldWidth * ratio;
                    canvas.height = oldHeight * ratio;
                    canvas.style.width = oldWidth + 'px';
                    canvas.style.height = oldHeight + 'px';
                    context.scale(ratio, ratio);
                    return true;
                } else if (devicePixelRatio == 1) {
                    canvas.style.width = canvas.width + 'px';
                    canvas.style.height = canvas.height + 'px';
                }
                return false;
            };
            function getRandomNum(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
            function getTimeStamp() { return new Date().getTime(); }
            function GameOverPanel(canvas, textSprite, restartImg, dimensions) {
                this.canvas = canvas;
                this.canvasCtx = canvas.getContext('2d');
                this.canvasDimensions = dimensions;
                this.textSprite = textSprite;
                this.restartImg = restartImg;
                this.draw();
            }
            GameOverPanel.dimensions = { TEXT_X: 0, TEXT_Y: 13, TEXT_WIDTH: 191, TEXT_HEIGHT: 11, RESTART_WIDTH: 36, RESTART_HEIGHT: 32 };
            GameOverPanel.prototype = {
                updateDimensions: function(width, opt_height) {
                    this.canvasDimensions.WIDTH = width;
                    if (opt_height) { this.canvasDimensions.HEIGHT = opt_height; }
                },
                draw: function() {
                    var dimensions = GameOverPanel.dimensions;
                    var centerX = this.canvasDimensions.WIDTH / 2;
                    var textSourceX = dimensions.TEXT_X;
                    var textSourceY = dimensions.TEXT_Y;
                    var textSourceWidth = dimensions.TEXT_WIDTH;
                    var textSourceHeight = dimensions.TEXT_HEIGHT;
                    var textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));
                    var textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);
                    var textTargetWidth = dimensions.TEXT_WIDTH;
                    var textTargetHeight = dimensions.TEXT_HEIGHT;
                    var restartSourceWidth = dimensions.RESTART_WIDTH;
                    var restartSourceHeight = dimensions.RESTART_HEIGHT;
                    var restartTargetX = centerX - (dimensions.RESTART_WIDTH / 2);
                    var restartTargetY = this.canvasDimensions.HEIGHT / 2;
                    if (IS_HIDPI) {
                        textSourceY *= 2; textSourceX *= 2; textSourceWidth *= 2;
                        textSourceHeight *= 2; restartSourceWidth *= 2; restartSourceHeight *= 2;
                    }
                    this.canvasCtx.drawImage(this.textSprite, textSourceX, textSourceY, textSourceWidth, textSourceHeight, textTargetX, textTargetY, textTargetWidth, textTargetHeight);
                    this.canvasCtx.drawImage(this.restartImg, 0, 0, restartSourceWidth, restartSourceHeight, restartTargetX, restartTargetY, dimensions.RESTART_WIDTH, dimensions.RESTART_HEIGHT);
                }
            };
            function checkForCollision(obstacle, tRex, opt_canvasCtx) {
                var tRexBox = new CollisionBox(tRex.xPos + 1, tRex.yPos + 1, tRex.config.WIDTH - 2, tRex.config.HEIGHT - 2);
                var obstacleBox = new CollisionBox(obstacle.xPos + 1, obstacle.yPos + 1, obstacle.typeConfig.width * obstacle.size - 2, obstacle.typeConfig.height - 2);
                if (boxCompare(tRexBox, obstacleBox)) {
                    var collisionBoxes = obstacle.collisionBoxes;
                    var tRexCollisionBoxes = tRex.ducking ? Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;
                    for (var t = 0; t < tRexCollisionBoxes.length; t++) {
                        for (var i = 0; i < collisionBoxes.length; i++) {
                            var adjTrexBox = createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);
                            var adjObstacleBox = createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);
                            var crashed = boxCompare(adjTrexBox, adjObstacleBox);
                            if (crashed) { return [adjTrexBox, adjObstacleBox]; }
                        }
                    }
                }
                return false;
            }
            function createAdjustedCollisionBox(box, adjustment) { return new CollisionBox(box.x + adjustment.x, box.y + adjustment.y, box.width, box.height); }
            function boxCompare(tRexBox, obstacleBox) {
                var crashed = false;
                if (tRexBox.x < obstacleBox.x + obstacleBox.width &&
                    tRexBox.x + tRexBox.width > obstacleBox.x &&
                    tRexBox.y < obstacleBox.y + obstacleBox.height &&
                    tRexBox.height + tRexBox.y > obstacleBox.y) {
                    crashed = true;
                }
                return crashed;
            }
            function CollisionBox(x, y, w, h) { this.x = x; this.y = y; this.width = w; this.height = h; }
            function Obstacle(canvasCtx, type, obstacleImg, dimensions, gapCoefficient, speed, opt_xOffset) {
                this.canvasCtx = canvasCtx;
                this.image = obstacleImg;
                this.typeConfig = type;
                this.gapCoefficient = gapCoefficient;
                this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);
                this.dimensions = dimensions;
                this.remove = false;
                this.xPos = dimensions.WIDTH + (opt_xOffset || 0);
                this.yPos = 0;
                this.width = 0;
                this.collisionBoxes = [];
                this.gap = 0;
                this.speedOffset = 0;
                this.currentFrame = 0;
                this.timer = 0;
                this.init(speed);
            }
            Obstacle.MAX_GAP_COEFFICIENT = 1.5;
            Obstacle.MAX_OBSTACLE_LENGTH = 3;
            Obstacle.prototype = {
                init: function(speed) {
                    this.cloneCollisionBoxes();
                    if (this.size > 1 && this.typeConfig.multipleSpeed > speed) { this.size = 1; }
                    this.width = this.typeConfig.width * this.size;
                    this.xPos = this.dimensions.WIDTH - this.width;
                    if (Array.isArray(this.typeConfig.yPos)) {
                        var yPosConfig = IS_MOBILE ? this.typeConfig.yPosMobile : this.typeConfig.yPos;
                        this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];
                    } else {
                        this.yPos = this.typeConfig.yPos;
                    }
                    this.draw();
                    if (this.size > 1) {
                        this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width - this.collisionBoxes[2].width;
                        this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;
                    }
                    this.gap = this.getGap(this.gapCoefficient, speed);
                },
                draw: function() {
                    var sourceWidth = this.typeConfig.width;
                    var sourceHeight = this.typeConfig.height;
                    if (IS_HIDPI) { sourceWidth *= 2; sourceHeight *= 2; }
                    var sourceX = (sourceWidth * this.size) * (0.5 * (this.size - 1));
                    this.canvasCtx.drawImage(this.image, sourceX, 0, sourceWidth * this.size, sourceHeight, this.xPos, this.yPos, this.typeConfig.width * this.size, this.typeConfig.height);
                },
                update: function(deltaTime, speed) {
                    if (!this.remove) {
                        this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);
                        this.draw();
                        if (!this.isVisible()) { this.remove = true; }
                    }
                },
                getGap: function(gapCoefficient, speed) {
                    var minGap = Math.round(this.width * speed + this.typeConfig.minGap * gapCoefficient);
                    var maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);
                    return getRandomNum(minGap, maxGap);
                },
                isVisible: function() { return this.xPos + this.width > 0; },
                cloneCollisionBoxes: function() {
                    var collisionBoxes = this.typeConfig.collisionBoxes;
                    for (var i = collisionBoxes.length - 1; i >= 0; i--) {
                        this.collisionBoxes[i] = new CollisionBox(collisionBoxes[i].x, collisionBoxes[i].y, collisionBoxes[i].width, collisionBoxes[i].height);
                    }
                }
            };
            Obstacle.types = [
                { type: 'CACTUS_SMALL', width: 17, height: 35, yPos: 105, multipleSpeed: 4, minGap: 120, collisionBoxes: [ new CollisionBox(0, 7, 5, 27), new CollisionBox(4, 0, 6, 34), new CollisionBox(10, 4, 7, 14) ] },
                { type: 'CACTUS_LARGE', width: 25, height: 50, yPos: 90, multipleSpeed: 7, minGap: 120, collisionBoxes: [ new CollisionBox(0, 12, 7, 38), new CollisionBox(8, 0, 7, 49), new CollisionBox(13, 10, 10, 38) ] }
            ];
            function Trex(canvas, image) {
                this.canvas = canvas; this.canvasCtx = canvas.getContext('2d');
                this.image = image; this.xPos = 0; this.yPos = 0; this.groundYPos = 0;
                this.currentFrame = 0; this.currentAnimFrames = []; this.blinkDelay = 0;
                this.animStartTime = 0; this.timer = 0; this.msPerFrame = 1000 / FPS;
                this.config = Trex.config; this.status = Trex.status.WAITING; this.jumping = false;
                this.jumpVelocity = 0; this.reachedMinHeight = false; this.speedDrop = false;
                this.jumpCount = 0; this.jumpspotX = 0; this.init();
            }
            Trex.config = { DROP_VELOCITY: -5, GRAVITY: 0.6, HEIGHT: 47, INITIAL_JUMP_VELOCITY: -10, INTRO_DURATION: 1500, MAX_JUMP_HEIGHT: 30, MIN_JUMP_HEIGHT: 30, SPEED_DROP_COEFFICIENT: 3, SPRITE_WIDTH: 262, START_X_POS: 50, WIDTH: 44, WIDTH_DUCK: 59 };
            Trex.collisionBoxes = { RUNNING: [ new CollisionBox(1, -1, 30, 26), new CollisionBox(32, 0, 8, 16), new CollisionBox(10, 35, 14, 8), new CollisionBox(1, 24, 29, 5), new CollisionBox(5, 30, 21, 4), new CollisionBox(9, 34, 15, 4) ]};
            Trex.status = { CRASHED: 'CRASHED', JUMPING: 'JUMPING', RUNNING: 'RUNNING', WAITING: 'WAITING' };
            Trex.BLINK_TIMING = 7000;
            Trex.animFrames = { WAITING: { frames: [44, 0], msPerFrame: 1000 / 3 }, RUNNING: { frames: [88, 132], msPerFrame: 1000 / 12 }, CRASHED: { frames: [220], msPerFrame: 1000 / 60 }, JUMPING: { frames: [0], msPerFrame: 1000 / 60 } };
            Trex.prototype = {
                init: function() {
                    this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT - Runner.config.BOTTOM_PAD;
                    this.yPos = this.groundYPos;
                    this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;
                    this.draw(0, 0);
                    this.update(0, Trex.status.WAITING);
                },
                setJumpVelocity: function(setting) { this.config.INITIAL_JUMP_VELOCITY = -setting; this.config.DROP_VELOCITY = -setting / 2; },
                update: function(deltaTime, opt_status) {
                    this.timer += deltaTime;
                    if (opt_status) {
                        this.status = opt_status; this.currentFrame = 0;
                        this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;
                        this.currentAnimFrames = Trex.animFrames[opt_status].frames;
                        if (opt_status == Trex.status.WAITING) {
                            this.animStartTime = getTimeStamp(); this.setBlinkDelay();
                        }
                    }
                    if (this.playingIntro && this.xPos < this.config.START_X_POS) {
                        this.xPos += Math.round((this.config.START_X_POS / this.config.INTRO_DURATION) * deltaTime);
                    }
                    if (this.status == Trex.status.WAITING) {
                        this.blink(getTimeStamp());
                    } else {
                        this.draw(this.currentAnimFrames[this.currentFrame], 0);
                    }
                    if (this.timer >= this.msPerFrame) {
                        this.currentFrame = this.currentFrame == this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;
                        this.timer = 0;
                    }
                },
                draw: function(x, y) {
                    var sourceX = x; var sourceY = y;
                    var sourceWidth = this.ducking ? this.config.WIDTH_DUCK : this.config.WIDTH;
                    var sourceHeight = this.config.HEIGHT;
                    if (IS_HIDPI) { sourceX *= 2; sourceY *= 2; sourceWidth *= 2; sourceHeight *= 2; }
                    this.canvasCtx.drawImage(this.image, sourceX, sourceY, sourceWidth, sourceHeight, this.xPos, this.yPos, this.config.WIDTH, this.config.HEIGHT);
                },
                setBlinkDelay: function() { this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING); },
                blink: function(time) {
                    var deltaTime = time - this.animStartTime;
                    if (deltaTime >= this.blinkDelay) {
                        this.draw(this.currentAnimFrames[this.currentFrame], 0);
                        if (this.currentFrame == 1) { this.setBlinkDelay(); this.animStartTime = time; }
                    }
                },
                startJump: function() { if (!this.jumping) { this.update(0, Trex.status.JUMPING); this.jumpVelocity = this.config.INITIAL_JUMP_VELOCITY; this.jumping = true; this.reachedMinHeight = false; this.speedDrop = false; } },
                endJump: function() { if (this.reachedMinHeight && this.jumpVelocity < this.config.DROP_VELOCITY) { this.jumpVelocity = this.config.DROP_VELOCITY; } },
                updateJump: function(deltaTime) {
                    var msPerFrame = Trex.animFrames[this.status].msPerFrame;
                    var framesElapsed = deltaTime / msPerFrame;
                    if (this.speedDrop) {
                        this.yPos += Math.round(this.jumpVelocity * this.config.SPEED_DROP_COEFFICIENT * framesElapsed);
                    } else {
                        this.yPos += Math.round(this.jumpVelocity * framesElapsed);
                    }
                    this.jumpVelocity += this.config.GRAVITY * framesElapsed;
                    if (this.yPos < this.minJumpHeight || this.speedDrop) { this.reachedMinHeight = true; }
                    if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) { this.endJump(); }
                    if (this.yPos > this.groundYPos) { this.reset(); this.jumpCount++; }
                    this.update(deltaTime);
                },
                setSpeedDrop: function() { this.speedDrop = true; this.jumpVelocity = 1; },
                reset: function() { this.yPos = this.groundYPos; this.jumpVelocity = 0; this.jumping = false; this.ducking = false; this.update(0, Trex.status.RUNNING); this.midair = false; this.speedDrop = false; this.jumpCount = 0; }
            };
            function DistanceMeter(canvas, spriteSheet, canvasWidth) {
                this.canvas = canvas; this.canvasCtx = canvas.getContext('2d');
                this.image = spriteSheet; this.x = 0; this.y = 5; this.currentDistance = 0;
                this.maxScore = 0; this.highScore = 0; this.digits = []; this.acheivement = false;
                this.defaultString = ''; this.flashTimer = 0; this.flashIterations = 0;
                this.config = DistanceMeter.config; this.init(canvasWidth);
            }
            DistanceMeter.dimensions = { WIDTH: 10, HEIGHT: 13, DEST_WIDTH: 11 };
            DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];
            DistanceMeter.config = { MAX_DISTANCE_UNITS: 5, ACHIEVEMENT_DISTANCE: 100, COEFFICIENT: 0.025, FLASH_DURATION: 1000 / 4, FLASH_ITERATIONS: 3 };
            DistanceMeter.prototype = {
                init: function(width) {
                    var maxDistanceStr = ''; this.calcXPos(width); this.maxScore = this.config.MAX_DISTANCE_UNITS;
                    for (var i = 0; i < this.config.MAX_DISTANCE_UNITS; i++) {
                        this.draw(i, 0); this.defaultString += '0'; maxDistanceStr += '9';
                    }
                    this.maxScore = parseInt(maxDistanceStr);
                },
                calcXPos: function(canvasWidth) { this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH * (this.config.MAX_DISTANCE_UNITS + 1)); },
                draw: function(digitPos, value, opt_highScore) {
                    var sourceWidth = DistanceMeter.dimensions.WIDTH; var sourceHeight = DistanceMeter.dimensions.HEIGHT;
                    var sourceX = DistanceMeter.dimensions.WIDTH * value;
                    var targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;
                    var targetY = this.y; var targetWidth = DistanceMeter.dimensions.WIDTH;
                    var targetHeight = DistanceMeter.dimensions.HEIGHT;
                    if (IS_HIDPI) { sourceWidth *= 2; sourceHeight *= 2; sourceX *= 2; }
                    this.canvasCtx.save();
                    if (opt_highScore) {
                        var highScoreX = this.x - (this.config.MAX_DISTANCE_UNITS * 2) * DistanceMeter.dimensions.WIDTH;
                        this.canvasCtx.translate(highScoreX, this.y);
                    } else {
                        this.canvasCtx.translate(this.x, this.y);
                    }
                    this.canvasCtx.drawImage(this.image, sourceX, 0, sourceWidth, sourceHeight, targetX, targetY, targetWidth, targetHeight);
                    this.canvasCtx.restore();
                },
                getActualDistance: function(distance) { return distance ? Math.round(distance * this.config.COEFFICIENT) : 0; },
                update: function(deltaTime, distance) {
                    var paint = true; var playSound = false;
                    if (!this.acheivement) {
                        distance = this.getActualDistance(distance);
                        if (distance > 0) {
                            if (distance % this.config.ACHIEVEMENT_DISTANCE == 0) {
                                this.acheivement = true; this.flashTimer = 0; playSound = true;
                            }
                            var distanceStr = (this.defaultString + distance).substr(-this.config.MAX_DISTANCE_UNITS);
                            this.digits = distanceStr.split('');
                        } else {
                            this.digits = this.defaultString.split('');
                        }
                    } else {
                        if (this.flashIterations <= this.config.FLASH_ITERATIONS) {
                            this.flashTimer += deltaTime;
                            if (this.flashTimer < this.config.FLASH_DURATION) {
                                paint = false;
                            } else if (this.flashTimer > this.config.FLASH_DURATION * 2) {
                                this.flashTimer = 0; this.flashIterations++;
                            }
                        } else {
                            this.acheivement = false; this.flashIterations = 0; this.flashTimer = 0;
                        }
                    }
                    if (paint) {
                        for (var i = this.digits.length - 1; i >= 0; i--) {
                            this.draw(i, parseInt(this.digits[i]));
                        }
                    }
                    this.drawHighScore();
                    return playSound;
                },
                drawHighScore: function() {
                    this.canvasCtx.save(); this.canvasCtx.globalAlpha = .8;
                    for (var i = this.highScore.length - 1; i >= 0; i--) {
                        this.draw(i, parseInt(this.highScore[i], 10), true);
                    }
                    this.canvasCtx.restore();
                },
                setHighScore: function(distance) {
                    distance = this.getActualDistance(distance);
                    var highScoreStr = (this.defaultString + distance).substr(-this.config.MAX_DISTANCE_UNITS);
                    this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));
                },
                reset: function() { this.update(0); this.acheivement = false; }
            };
            function Cloud(canvas, cloudImg, containerWidth) {
                this.canvas = canvas; this.canvasCtx = this.canvas.getContext('2d');
                this.image = cloudImg; this.containerWidth = containerWidth;
                this.xPos = containerWidth; this.yPos = 0; this.remove = false;
                this.cloudGap = getRandomNum(Cloud.config.MIN_CLOUD_GAP, Cloud.config.MAX_CLOUD_GAP);
                this.init();
            }
            Cloud.config = { HEIGHT: 14, MAX_CLOUD_GAP: 400, MAX_SKY_LEVEL: 30, MIN_CLOUD_GAP: 100, MIN_SKY_LEVEL: 71, WIDTH: 46 };
            Cloud.prototype = {
                init: function() { this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL, Cloud.config.MIN_SKY_LEVEL); this.draw(); },
                draw: function() {
                    this.canvasCtx.save(); var sourceWidth = Cloud.config.WIDTH; var sourceHeight = Cloud.config.HEIGHT;
                    if (IS_HIDPI) { sourceWidth *= 2; sourceHeight *= 2; }
                    this.canvasCtx.drawImage(this.image, 0, 0, sourceWidth, sourceHeight, this.xPos, this.yPos, Cloud.config.WIDTH, Cloud.config.HEIGHT);
                    this.canvasCtx.restore();
                },
                update: function(speed) { if (!this.remove) { this.xPos -= Math.ceil(speed); this.draw(); if (!this.isVisible()) { this.remove = true; } } },
                isVisible: function() { return this.xPos + Cloud.config.WIDTH > 0; }
            };
            function HorizonLine(canvas, bgImg) {
                this.image = bgImg; this.canvas = canvas; this.canvasCtx = canvas.getContext('2d');
                this.sourceDimensions = {}; this.dimensions = HorizonLine.dimensions;
                this.sourceXPos = [0, this.dimensions.WIDTH]; this.xPos = []; this.yPos = 0;
                this.bumpThreshold = 0.5; this.setSourceDimensions(); this.draw();
            }
            HorizonLine.dimensions = { WIDTH: 600, HEIGHT: 12, YPOS: 127 };
            HorizonLine.prototype = {
                setSourceDimensions: function() {
                    for (var dimension in HorizonLine.dimensions) {
                        if (IS_HIDPI) {
                            if (dimension != 'YPOS') {
                                this.sourceDimensions[dimension] = HorizonLine.dimensions[dimension] * 2;
                            }
                        } else {
                            this.sourceDimensions[dimension] = HorizonLine.dimensions[dimension];
                        }
                        this.dimensions[dimension] = HorizonLine.dimensions[dimension];
                    }
                    this.xPos = [0, HorizonLine.dimensions.WIDTH];
                    this.yPos = HorizonLine.dimensions.YPOS;
                },
                getRandomType: function() { return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0; },
                draw: function() {
                    this.canvasCtx.drawImage(this.image, this.sourceXPos[0], 0, this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT, this.xPos[0], this.yPos, this.dimensions.WIDTH, this.dimensions.HEIGHT);
                    this.canvasCtx.drawImage(this.image, this.sourceXPos[1], 0, this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT, this.xPos[1], this.yPos, this.dimensions.WIDTH, this.dimensions.HEIGHT);
                },
                updateXPos: function(pos, increment) {
                    var line1 = pos; var line2 = pos == 0 ? 1 : 0;
                    this.xPos[line1] -= increment;
                    this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;
                    if (this.xPos[line1] <= -this.dimensions.WIDTH) {
                        this.xPos[line1] += this.dimensions.WIDTH * 2;
                        this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;
                        this.sourceXPos[line1] = this.getRandomType();
                    }
                },
                update: function(deltaTime, speed) {
                    var increment = Math.floor(speed * (FPS / 1000) * deltaTime);
                    if (this.xPos[0] <= 0) {
                        this.updateXPos(0, increment);
                    } else {
                        this.updateXPos(1, increment);
                    }
                    this.draw();
                },
                reset: function() { this.xPos[0] = 0; this.xPos[1] = HorizonLine.dimensions.WIDTH; }
            };
            function Horizon(canvas, images, dimensions, gapCoefficient) {
                this.canvas = canvas; this.canvasCtx = this.canvas.getContext('2d');
                this.config = Horizon.config; this.dimensions = dimensions; this.gapCoefficient = gapCoefficient;
                this.obstacles = []; this.horizonOffsets = [0, 0]; this.cloudFrequency = this.config.CLOUD_FREQUENCY;
                this.clouds = []; this.cloudImg = images.CLOUD; this.cloudSpeed = this.config.BG_CLOUD_SPEED;
                this.horizonImg = images.HORIZON; this.horizonLine = null;
                this.obstacleImgs = { CACTUS_SMALL: images.CACTUS_SMALL, CACTUS_LARGE: images.CACTUS_LARGE };
                this.init();
            }
            Horizon.config = { BG_CLOUD_SPEED: 0.2, BUMPY_THRESHOLD: .3, CLOUD_FREQUENCY: .5, HORIZON_HEIGHT: 16, MAX_CLOUDS: 6 };
            Horizon.prototype = {
                init: function() { this.addCloud(); this.horizonLine = new HorizonLine(this.canvas, this.horizonImg); },
                update: function(deltaTime, currentSpeed, updateObstacles) {
                    this.runningTime += deltaTime;
                    this.horizonLine.update(deltaTime, currentSpeed);
                    this.updateClouds(deltaTime, currentSpeed);
                    if (updateObstacles) { this.updateObstacles(deltaTime, currentSpeed); }
                },
                updateClouds: function(deltaTime, speed) {
                    var cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;
                    var numClouds = this.clouds.length;
                    if (numClouds) {
                        for (var i = numClouds - 1; i >= 0; i--) { this.clouds[i].update(cloudSpeed); }
                        var lastCloud = this.clouds[numClouds - 1];
                        if (numClouds < this.config.MAX_CLOUDS && (this.dimensions.WIDTH - lastCloud.xPos) > lastCloud.cloudGap && this.cloudFrequency > Math.random()) {
                            this.addCloud();
                        }
                        this.clouds = this.clouds.filter(function(obj) { return !obj.remove; });
                    } else { this.addCloud(); }
                },
                updateObstacles: function(deltaTime, currentSpeed) {
                    var updatedObstacles = this.obstacles.slice(0);
                    for (var i = 0; i < this.obstacles.length; i++) {
                        var obstacle = this.obstacles[i];
                        obstacle.update(deltaTime, currentSpeed);
                        if (obstacle.remove) { updatedObstacles.shift(); }
                    }
                    this.obstacles = updatedObstacles;
                    if (this.obstacles.length > 0) {
                        var lastObstacle = this.obstacles[this.obstacles.length - 1];
                        if (lastObstacle && !lastObstacle.followingObstacleCreated && lastObstacle.isVisible() && (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) < this.dimensions.WIDTH) {
                            this.addNewObstacle(currentSpeed);
                            lastObstacle.followingObstacleCreated = true;
                        }
                    } else {
                        this.addNewObstacle(currentSpeed);
                    }
                },
                addNewObstacle: function(currentSpeed) {
                    var obstacleTypeIndex = getRandomNum(0, Obstacle.types.length - 1);
                    var obstacleType = Obstacle.types[obstacleTypeIndex];
                    var obstacleImg = this.obstacleImgs[obstacleType.type];
                    this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType, obstacleImg, this.dimensions, this.gapCoefficient, currentSpeed, obstacleType.width));
                },
                reset: function() { this.obstacles = []; this.horizonLine.reset(); },
                resize: function(width, height) { this.canvas.width = width; this.canvas.height = height; },
                addCloud: function() { this.clouds.push(new Cloud(this.canvas, this.cloudImg, this.dimensions.WIDTH)); }
            };
        })();
    </script><!--SCRIPT UFFICIALI DELLA PAGINA OFFLINE DI GOOGLE CHROME-->
    <script>
        // --- KEY CHANGE: Use 'load' to ensure the page height is final ---
        window.addEventListener('load', () => {

            // --- Configuration ---
            const GIF_HEIGHT = 150; // The height of each GIF in pixels. Match this to your CSS.
            const MIN_DISTANCE = 5; // The same GIF won't appear within this many spots.

            // --- Main Logic ---
            const leftContainer = document.querySelector('.advertisement-left-container');
            const rightContainer = document.querySelector('.advertisement-right-container');
            const webpageContainer = document.querySelector('.smuzn-webpage');

            if (!webpageContainer) {
                console.error("The '.smuzn-webpage' container was not found. Cannot calculate page height.");
                return;
            }

            // 1. Gather all unique GIFs from the initial HTML to create a master list.
            // We only need to check one container since they should have the same sources.
            const masterGifList = getUniqueGifsFromDOM('.advertisement-left-container a');

            if (masterGifList.length === 0) {
                console.error("No source GIFs found in '.advertisement-left-container'. Halting script.");
                return;
            }

            if (masterGifList.length <= MIN_DISTANCE) {
                console.warn(`Warning: The number of unique GIFs (${masterGifList.length}) is not greater than the minimum distance (${MIN_DISTANCE}). The no-repeat rule may not always be followed.`);
            }

            // 2. --- KEY CHANGE: Calculate GIFs needed based on the full page height ---
            const pageHeight = webpageContainer.offsetHeight;
            const gifsNeeded = Math.ceil(pageHeight / GIF_HEIGHT);

            // 3. Generate the randomized lists for left and right columns.
            const leftGifs = generateRandomizedGifList(masterGifList, gifsNeeded, MIN_DISTANCE);
            const rightGifs = generateRandomizedGifList(masterGifList, gifsNeeded, MIN_DISTANCE);

            // 4. Populate the containers with the new, randomized GIFs.
            populateContainer(leftContainer, leftGifs);
            populateContainer(rightContainer, rightGifs);
        });


        /**
         * Scans the DOM for image sources and returns a unique list of objects,
         * each containing the image src and its inline style.
         * @param {string} selector - The CSS selector for the elements containing the images.
         * @returns {Array<{src: string, style: string|null}>} An array of unique GIF data objects.
         */
        function getUniqueGifsFromDOM(selector) {
            const sourceElements = document.querySelectorAll(selector);
            const uniqueGifs = new Map();

            sourceElements.forEach(el => {
                const img = el.querySelector('img');
                if (img && img.src && !uniqueGifs.has(img.src)) {
                    uniqueGifs.set(img.src, {
                        src: img.src,
                        style: img.getAttribute('style')
                    });
                }
            });

            return Array.from(uniqueGifs.values());
        }

        /**
         * Generates a list of random GIF objects, ensuring no GIF repeats within the minDistance.
         * @param {Array} sourceList - The master list of unique GIF data objects.
         * @param {number} count - The number of GIFs to generate for the list.
         * @param {number} minDistance - The minimum distance between identical GIFs.
         * @returns {Array} A new array of GIF data objects.
         */
        function generateRandomizedGifList(sourceList, count, minDistance) {
            const resultList = [];
            const recentSources = [];

            for (let i = 0; i < count; i++) {
                let availableGifs = sourceList.filter(gif => !recentSources.includes(gif.src));
                if (availableGifs.length === 0) {
                    availableGifs = sourceList;
                }

                const randomIndex = Math.floor(Math.random() * availableGifs.length);
                const chosenGif = availableGifs[randomIndex];

                resultList.push(chosenGif);
                recentSources.push(chosenGif.src);
                if (recentSources.length > minDistance) {
                    recentSources.shift();
                }
            }
            return resultList;
        }

        /**
         * Clears a container and fills it with new GIF elements based on a list.
         * @param {HTMLElement} container - The container element to populate.
         * @param {Array} gifList - The list of GIF data objects to add.
         */
        function populateContainer(container, gifList) {
            container.innerHTML = '';
            const fragment = document.createDocumentFragment();

            gifList.forEach(gifData => {
                const link = document.createElement('a');
                link.href = "";
                const img = document.createElement('img');
                img.className = 'advertisement';
                img.src = gifData.src;
                if (gifData.style) {
                    img.setAttribute('style', gifData.style);
                }
                link.appendChild(img);
                fragment.appendChild(link);
            });
            container.appendChild(fragment);
        }
    </script><!--SCRIPT PUBBLICITÀ RANDOM DA INIZIO A FINE PAGINA-->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- CONFIGURAZIONE ---
            const rssFeedUrl = 'https://www.ilsole24ore.com/rss/italia--attualita.xml';
            const proxyUrl = 'https://api.allorigins.win/raw?url=';
            const fullUrl = `${proxyUrl}${encodeURIComponent(rssFeedUrl)}`;
            const placeholderImage = 'https://via.placeholder.com/400x200.png?text=No+Image';
            const maxTitleLength = 65;
            const maxWordLength = 13; // NUOVO: Lunghezza massima di una parola prima di spezzarla

            // --- FUNZIONI AUSILIARIE ---

            /**
             * NUOVO: Spezza le parole troppo lunghe in una stringa inserendo un trattino.
             * @param {string} text - Il testo di input.
             * @param {number} maxLength - La lunghezza massima consentita per una parola.
             * @param {string} breakChar - Il carattere da inserire (es. "-").
             * @returns {string} Il testo con le parole lunghe spezzate.
             */
            function breakLongWords(text, maxLength, breakChar = '-') {
                const words = text.split(' ');
                const processedWords = words.map(word => {
                    if (word.length <= maxLength) {
                        return word; // La parola è ok, restituiscila così com'è
                    }
                    // La parola è troppo lunga, spezziamola
                    const parts = [];
                    for (let i = 0; i < word.length; i += maxLength) {
                        parts.push(word.substring(i, i + maxLength));
                    }
                    return parts.join(breakChar);
                });
                return processedWords.join(' ');
            }

            function truncateText(text, maxLength) {
                if (text.length <= maxLength) {
                    return text;
                }
                return text.slice(0, maxLength) + '...';
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function formatRelativeTime(dateString) {
                const date = new Date(dateString);
                const now = new Date();
                const seconds = Math.round((now - date) / 1000);
                const minutes = Math.round(seconds / 60);
                const hours = Math.round(minutes / 60);
                const days = Math.round(hours / 24);

                if (seconds < 60) return "Poco fa";
                if (minutes < 60) return `${minutes} minut${minutes > 1 ? 'i' : 'o'} fa`;
                if (hours < 24) return `${hours} or${hours > 1 ? 'e' : 'a'} fa`;
                return `${days} giorn${days > 1 ? 'i' : 'o'} fa`;
            }

            // --- FUNZIONE PRINCIPALE ---
            async function loadAndDisplayRandomNews() {
                try {
                    const response = await fetch(fullUrl);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const xmlText = await response.text();

                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "application/xml");

                    if (xmlDoc.querySelector("parsererror")) {
                        console.error("Error parsing XML:", xmlDoc.querySelector("parsererror"));
                        return;
                    }

                    const items = xmlDoc.querySelectorAll('item');
                    let newsData = Array.from(items).map(item => ({
                        title: item.querySelector('title')?.textContent.trim() || 'No Title',
                        link: item.querySelector('link')?.textContent || '#',
                        pubDate: item.querySelector('pubDate')?.textContent || '',
                        description: item.querySelector('description')?.textContent.trim() || '',
                        imageUrl: item.querySelector('enclosure')?.getAttribute('url') || placeholderImage,
                        year: item.querySelector('pubDate')?.textContent ? new Date(item.querySelector('pubDate').textContent).getFullYear() : ''
                    }));

                    shuffleArray(newsData);

                    const newsSlots = document.querySelectorAll('.link-news');

                    newsSlots.forEach((slot, index) => {
                        if (index >= newsData.length) {
                            slot.style.display = 'none';
                            return;
                        }

                        const newsItem = newsData[index];

                        const linkElement = slot;
                        const imageElement = slot.querySelector('.news-imgs');
                        const titleElement = slot.querySelector('.text-news-right');
                        const dateElement = slot.querySelector('.text-news-bottom');
                        const infoBox = slot.querySelector('.news-windows-box-info');

                        if (infoBox) {
                            infoBox.setAttribute('data-title', newsItem.title);
                            infoBox.setAttribute('data-news', newsItem.description);
                            infoBox.setAttribute('data-year', String(newsItem.year));
                        }

                        if (linkElement) linkElement.href = newsItem.link;
                        if (imageElement) imageElement.src = newsItem.imageUrl;

                        if (titleElement) {
                            // MODIFICA: Applica prima il word-breaking, poi il troncamento
                            const brokenTitle = breakLongWords(newsItem.title, maxWordLength);
                            const finalTitle = truncateText(brokenTitle, maxTitleLength);

                            titleElement.textContent = finalTitle;

                            if (dateElement) {
                                dateElement.textContent = `${formatRelativeTime(newsItem.pubDate)}`;
                                titleElement.appendChild(dateElement);
                            }
                        }
                    });

                } catch (error) {
                    console.error("Failed to load news feed:", error);
                }
            }

            loadAndDisplayRandomNews();
        });
    </script><!--SCRIPT NOTIZIE RANDOMIZZATE-->
    <script>
        /**
         * ===================================================================
         * SCRIPT UNIFICATO PER LA GESTIONE DINAMICA DELLA PAGINA (v5.1 - Hydra Ads)
         * ===================================================================
         * v4: Introduce un offset di 5vmin nel calcolo dell'altezza.
         * v5: Modifica la logica dei bottoni "x": la chiusura di un annuncio
         *     ne genera da 2 a 4 duplicati in posizioni casuali all'interno
         *     del viewport, creando un ciclo di duplicazione.
         * v5.1: Rimuove i margini orizzontali (margin-left, margin-right)
         *       dalle immagini duplicate per un posizionamento assoluto preciso.
         */
        window.addEventListener('load', () => {

            let updateButtonPositions;

            // -------------------------------------------------------------------
            // FUNZIONE 1: IMPOSTAZIONE VARIABILI CSS GLOBALI (INVARIATA)
            // -------------------------------------------------------------------
            function initializeCssVariables() {
                const sourceElement = document.querySelector('.immagine-principale-bordo');
                const rootElement = document.documentElement;
                if (!sourceElement) {
                    console.error("Script Unificato: Impossibile trovare l'elemento sorgente '.immagine-principale-bordo'.");
                    return;
                }
                const syncAndSetCssVariables = () => {
                    const sourceRect = sourceElement.getBoundingClientRect();
                    rootElement.style.setProperty('--larghezza-copia', `${sourceRect.width}px`);
                    rootElement.style.setProperty('--altezza-copia', `${sourceRect.height}px`);
                };
                syncAndSetCssVariables();
                const resizeObserver = new ResizeObserver(syncAndSetCssVariables);
                resizeObserver.observe(sourceElement);
                console.log("✅ Funzione 1 (Variabili CSS) inizializzata.");
            }


            // -------------------------------------------------------------------
            // FUNZIONE 2: GESTIONE BOTTONI "X" INTERATTIVI (LOGICA DI DUPLICAZIONE AGGIUNTA)
            // -------------------------------------------------------------------
            function initializeCloseButtons() {
                // --- SETUP INIZIALE E VARIABILI CONDIVISE ---
                const pagesContainer = document.querySelector('.pages');
                if (!pagesContainer) { console.warn('Script Unificato: Container .pages non trovato per i bottoni.'); return; }
                if (window.getComputedStyle(pagesContainer).position === 'static') { pagesContainer.style.position = 'relative'; }

                const interactiveAds = new Map(); // Traccia tutti gli annunci (originali e duplicati) e i loro bottoni.

                // --- INIEZIONE DEGLI STILI PER I BOTTONI (INVARIATO) ---
                const buttonStyles = { 'position': 'absolute', 'display': 'none', 'align-items': 'center', 'justify-content': 'center', 'width': '2vmin', 'height': '2vmin', 'padding-bottom': '0.5vmin', 'font-family': 'Comic Relief, system-ui', 'font-weight': '400', 'font-style': 'normal', 'font-size': '2.25vmin', 'border-radius': '0.5vmin 0 0.5vmin 0', 'user-select': 'none', 'color': 'white', 'background-color': 'var(--bgc)', 'z-index': '5555', 'box-shadow': '0 0 0 0 white', 'opacity': '0', 'transition': 'all 0.1s ease-in-out', 'transform': 'translate(-140%, 40%) scale(1)', 'cursor': 'pointer !important' };
                const buttonHoverStyles = { 'transform': 'translate(-140%, 40%) scale(1.2)', 'box-shadow': '0 0 0 0 var(--bgc)' };
                (function injectStyles(selector, styles, hoverSelector, hoverStyles) { const toCss = (obj) => Object.entries(obj).map(([k, v]) => `${k}:${v};`).join(''); const styleEl = document.createElement('style'); styleEl.textContent = `${selector} { ${toCss(styles)} } ${hoverSelector} { ${toCss(hoverStyles)} }`; document.head.appendChild(styleEl); })('.interactive-close-button', buttonStyles, '.interactive-close-button:hover', buttonHoverStyles);

                // --- FUNZIONI HELPER (INVARIATE) ---
                const isIntersecting = (r1, r2) => r1.left < r2.right && r1.right > r2.left && r1.top < r2.bottom && r1.bottom > r2.top;
                const calculateImageVisibleRect = (img) => { const imgRect = img.getBoundingClientRect(); if (window.getComputedStyle(img).objectFit !== 'contain' || !img.naturalWidth) return imgRect; const naturalRatio = img.naturalWidth / img.naturalHeight; const elementRatio = img.width / img.height; const r = { ...imgRect.toJSON() }; if (naturalRatio > elementRatio) { const h = img.width / naturalRatio; r.top += (img.height - h) / 2; r.height = h; } else { const w = img.height * naturalRatio; r.left += (img.width - w) / 2; r.width = w; } r.right = r.left + r.width; r.bottom = r.top + r.height; return r; };

                // --- NUOVE FUNZIONI CENTRALI ---

                /**
                 * Crea da 2 a 4 duplicati di un annuncio chiuso, posizionandoli
                 * casualmente all'interno del viewport.
                 * @param {HTMLElement} originalAnchor - L'elemento 'a' da duplicare.
                 */
                const createDuplicates = (originalAnchor) => {
                    const numDuplicates = Math.floor(Math.random() * 3) + 2; // Random tra 2 e 4
                    const originalRect = originalAnchor.getBoundingClientRect();

                    for (let i = 0; i < numDuplicates; i++) {
                        const clone = originalAnchor.cloneNode(true);

                        // *** INIZIO MODIFICA: RIMOZIONE MARGINI ***
                        // Trova l'immagine all'interno del clone.
                        const clonedImg = clone.querySelector('img');
                        // Se l'immagine esiste, rimuovi i margini orizzontali dal suo stile inline
                        // per garantire che il posizionamento assoluto non sia alterato.
                        if (clonedImg) {
                            clonedImg.style.marginLeft = '';
                            clonedImg.style.marginRight = '';
                        }
                        // *** FINE MODIFICA ***

                        // Calcola posizione casuale DENTRO il viewport
                        const maxLeft = window.innerWidth - originalRect.width;
                        const maxTop = window.innerHeight - originalRect.height;
                        const randomLeft = Math.random() * Math.max(0, maxLeft);
                        const randomTop = window.scrollY + (Math.random() * Math.max(0, maxTop)); // Aggiunge lo scroll per la posizione assoluta nel documento

                        // Applica stili per il posizionamento e la visibilità
                        clone.style.position = 'absolute';
                        clone.style.left = `${randomLeft}px`;
                        clone.style.top = `${randomTop}px`;
                        clone.style.opacity = '1'; // Rende visibile il duplicato
                        clone.style.pointerEvents = 'auto'; // Riattiva l'interazione
                        clone.style.zIndex = '5550'; // Assicura che sia in primo piano
                        clone.style.border = '0.01vmin solid #f8f8f8';


                        pagesContainer.appendChild(clone);

                        // Rende il nuovo clone interattivo, creando il ciclo
                        makeAdInteractive(clone);
                    }
                    // Forza un aggiornamento immediato delle posizioni dei bottoni
                    if (updateButtonPositions) updateButtonPositions();
                };

                /**
                 * Rende un annuncio (elemento 'a') interattivo, aggiungendo il bottone 'x'
                 * e la logica di hover e click.
                 * @param {HTMLElement} anchor - L'elemento 'a' da rendere interattivo.
                 */
                const makeAdInteractive = (anchor) => {
                    if (interactiveAds.has(anchor)) return; // Evita di aggiungere logica duplicata

                    const button = document.createElement('span');
                    button.className = 'interactive-close-button';
                    button.textContent = 'x';
                    pagesContainer.appendChild(button);

                    interactiveAds.set(anchor, { button });

                    let hideTimer;
                    const handleHover = (e) => {
                        clearTimeout(hideTimer);
                        if (e.type === 'mouseenter') {
                            if (button.style.display !== 'none') button.style.opacity = '1';
                        } else {
                            hideTimer = setTimeout(() => { button.style.opacity = '0'; }, 100);
                        }
                    };

                    [anchor, button].forEach(el => {
                        el.addEventListener('mouseenter', handleHover);
                        el.addEventListener('mouseleave', handleHover);
                    });

                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        clearTimeout(hideTimer);

                        // 1. Nasconde l'annuncio e il suo bottone
                        anchor.style.opacity = '0';
                        anchor.style.pointerEvents = 'none';
                        button.style.display = 'none';

                        // 2. Rimuove gli event listener per pulizia
                        [anchor, button].forEach(el => {
                            el.removeEventListener('mouseenter', handleHover);
                            el.removeEventListener('mouseleave', handleHover);
                        });

                        // 3. Avvia la creazione dei duplicati
                        createDuplicates(anchor);

                    }, { once: true });
                };

                // --- FUNZIONE DI AGGIORNAMENTO POSIZIONI (MODIFICATA PER USARE la nuova Map) ---
                updateButtonPositions = () => {
                    if (!pagesContainer) return;
                    const pagesRect = pagesContainer.getBoundingClientRect();
                    interactiveAds.forEach(({ button }, anchor) => {
                        if (anchor.style.opacity === '0' || anchor.style.display === 'none') {
                            button.style.display = 'none';
                            return;
                        }
                        const croppingContainer = anchor.closest('.advertisement-left-container, .advertisement-right-container');
                        const img = anchor.querySelector('img');
                        if (!img) return;

                        // Per i duplicati posizionati assolutamente, non c'è cropping container
                        const isVisible = !croppingContainer || isIntersecting(img.getBoundingClientRect(), croppingContainer.getBoundingClientRect());

                        if (isVisible) {
                            button.style.display = 'flex';
                            const visibleRect = calculateImageVisibleRect(img);
                            button.style.top = `${visibleRect.top - pagesRect.top}px`;
                            button.style.left = `${visibleRect.right - pagesRect.left}px`;
                        } else {
                            button.style.display = 'none';
                        }
                    });
                };

                // --- AVVIO E GESTIONE EVENTI ---
                let throttleTimer;
                const throttledUpdate = () => { if (throttleTimer) return; throttleTimer = setTimeout(() => { updateButtonPositions(); throttleTimer = null; }, 150); };
                window.addEventListener('resize', throttledUpdate);
                window.addEventListener('scroll', throttledUpdate, { passive: true });

                // Trova tutti gli annunci iniziali e li rende interattivi
                document.querySelectorAll('a img').forEach(img => {
                    const anchor = img.closest('a');
                    if (!anchor || anchor.classList.contains('link-news')) return;
                    makeAdInteractive(anchor);
                });

                console.log("✅ Funzione 2 (Annunci Interattivi Hydra) inizializzata.");
            }


            // -------------------------------------------------------------------
            // FUNZIONE 3: SINCRONIZZAZIONE ALTEZZA CON OFFSET DI 5VMIN (INVARIATA)
            // -------------------------------------------------------------------
            function initializeHeightSync() {
                const mainContent = document.querySelector('.smuzn-webpage');
                const footer = document.querySelector('footer');
                const targetDivs = document.querySelectorAll('.advertisement-left-container, .advertisement-right-container');

                if (!mainContent || !footer || targetDivs.length === 0) {
                    console.warn("Script Unificato: Impossibile trovare .smuzn-webpage, footer, o i contenitori per la sincronizzazione dell'altezza.");
                    return;
                }

                const syncHeightToFooter = () => {
                    const mainContentRect = mainContent.getBoundingClientRect();
                    const footerRect = footer.getBoundingClientRect();
                    const totalHeight = footerRect.bottom - mainContentRect.top;
                    const offsetInPixels = 2.2 * Math.min(window.innerWidth, window.innerHeight) / 100;
                    const finalHeight = totalHeight - offsetInPixels;
                    if (finalHeight <= 0) return;
                    targetDivs.forEach(div => {
                        div.style.height = `${Math.max(0, finalHeight)}px`;
                    });
                    if (updateButtonPositions) {
                        updateButtonPositions();
                    }
                };

                syncHeightToFooter();
                const resizeObserver = new ResizeObserver(syncHeightToFooter);
                resizeObserver.observe(mainContent);
                resizeObserver.observe(footer);
                let throttleTimer;
                const throttledSync = () => { if (throttleTimer) return; throttleTimer = setTimeout(() => { syncHeightToFooter(); throttleTimer = null; }, 100); };
                window.addEventListener('resize', throttledSync);

                console.log("✅ Funzione 3 (Sincronizzazione Altezza con Offset) inizializzata.");
            }


            // ===================================================================
            // ESECUZIONE PRINCIPALE
            // ===================================================================
            console.log("Script Unificato: La pagina è completamente caricata. Avvio delle funzioni...");

            initializeCssVariables();
            initializeCloseButtons(); // Ora avvia la logica di duplicazione
            initializeHeightSync();

            if (updateButtonPositions) {
                updateButtonPositions();
            }

            console.log("🚀 Script Unificato: Setup completato.");
        });
    </script><!--SINCRONIZZAZIONE ALTEZZA PER TAGLIO FINE PAGINA PUBBLICITÀ + AGGIUNTA "X" PER CHIUDERE ADVERT (CON DUPLICAZIONE) + SYNC PER PAZIO TESTO-->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Il tuo codice per il POPUP VIDEO rimane qui, invariato ---
            // ...

            // --- LOGICA BARRA DI PROSEGUIMENTO LETTURA (con zona di progressione personalizzata) ---

            // 1. Seleziona gli elementi necessari
            const articleBox = document.querySelector('.testo-articolo-sub-box');
            const progressBar = document.getElementById('reading-progress-bar');
            const footer = document.querySelector('footer'); // L'elemento che definisce la fine

            // Controlliamo che tutti gli elementi esistano per evitare errori
            if (!articleBox || !progressBar || !footer) {
                console.warn("Elementi necessari per la barra di progresso non trovati (articleBox, progressBar, o footer).");
                return;
            }

            const updateCustomProgressBar = () => {
                // --- ALLINEAMENTO VISIVO (come prima) ---
                const articleRect = articleBox.getBoundingClientRect();
                const articleWidth = articleRect.width;
                const articleLeftOffset = articleRect.left;

                // --- CALCOLO DELLA ZONA DI PROGRESSIONE ---

                // 1. Il punto finale dello scroll è quando il fondo della finestra tocca la cima del footer.
                // Usiamo getBoundingClientRect().top + window.scrollY per ottenere la posizione assoluta del footer,
                // che è più affidabile di offsetTop in layout complessi.
                const footerPositionTop = footer.getBoundingClientRect().top + window.scrollY;
                const scrollEndPoint = footerPositionTop - window.innerHeight;

                // 2. La distanza totale da percorrere è semplicemente scrollEndPoint, dato che partiamo da 0.
                const totalScrollDistance = scrollEndPoint;

                // 3. Calcoliamo la frazione di progresso.
                let progressFraction = 0;
                if (totalScrollDistance > 0) {
                    // Calcoliamo la progressione solo se c'è effettivamente spazio per scrollare.
                    progressFraction = window.scrollY / totalScrollDistance;
                }

                // 4. FONDAMENTALE: Limitiamo il valore tra 0 e 1 (0% - 100%).
                // Questo garantisce che la barra si fermi esattamente al 100% e non vada oltre.
                const clampedProgress = Math.max(0, Math.min(progressFraction, 1));

                // --- APPLICAZIONE DEGLI STILI ---
                const currentBarWidth = articleWidth * clampedProgress;

                progressBar.style.left = `${articleLeftOffset}px`;
                progressBar.style.width = `${currentBarWidth}px`;
            };

            // Aggiungiamo gli ascoltatori di eventi
            window.addEventListener('scroll', updateCustomProgressBar);
            window.addEventListener('resize', updateCustomProgressBar);

            // Eseguiamo subito per un posizionamento corretto al caricamento
            updateCustomProgressBar();
        });
    </script><!--SCRIPT BARRA DI PROSEGUIMENTO-->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- CONFIGURAZIONE POPUP ---
            const videoData = [
                {
                    title: "Mangiamo carne di squalo senza saperlo",
                    imageUrl: "https://i.ytimg.com/vi/Q2DWcy6skUs/hq720.jpg",
                    videoUrl: "https://youtu.be/Q2DWcy6skUs?si=iHA6Oy1HzjtMInTB"
                },
                {
                    title: "Computer Quantistici, Spiegazione Animata",
                    imageUrl: "https://i.ytimg.com/vi/n-i03wnWu9k/hq720.jpg",
                    videoUrl: "https://youtu.be/n-i03wnWu9k"
                },
                {
                    title: "Perché le buche sulla spiaggia sono così mortali?",
                    imageUrl: "https://i.ytimg.com/vi/0kQXOTcEB_E/hq720.jpg",
                    videoUrl: "https://youtu.be/0kQXOTcEB_E"
                }
            ];
            // --------------------

            // Selezione degli elementi del DOM del Popup
            const overlay = document.getElementById('video-modal-overlay');
            const modalContainer = document.querySelector('.video-modal-container');
            const closeButton = document.getElementById('video-modal-close');
            const modalTitle = document.getElementById('video-modal-title');
            const modalImage = document.getElementById('video-modal-image');
            const playLink = document.getElementById('video-modal-play-link');

            let popupTimer;

            // Funzione per generare un ritardo casuale in millisecondi
            const getRandomDelay = (minSeconds, maxSeconds) => {
                // PICCOLA CORREZIONE: Moltiplico per 1000 per convertire i secondi in millisecondi
                return (Math.random() * (maxSeconds - minSeconds) + minSeconds) * 1000;
            };

            // Funzione per mostrare il popup con un video casuale
            const showRandomVideoPopup = () => {
                if (videoData.length === 0) {
                    console.warn("Nessun video da mostrare nel popup.");
                    return;
                }
                const randomIndex = Math.floor(Math.random() * videoData.length);
                const video = videoData[randomIndex];
                modalTitle.textContent = video.title;
                modalImage.src = video.imageUrl;
                playLink.href = video.videoUrl;
                overlay.classList.add('visible');
            };

            // Funzione per nascondere il popup
            const hideVideoPopup = () => {
                overlay.classList.remove('visible');
                clearTimeout(popupTimer);
                popupTimer = setTimeout(showRandomVideoPopup, getRandomDelay(10, 20));
            };

            // --- Event Listeners del Popup ---

            closeButton.addEventListener('click', hideVideoPopup);

            overlay.addEventListener('click', (event) => {
                if (event.target === overlay) {
                    hideVideoPopup();
                }
            });

            modalContainer.addEventListener('click', (event) => {
                event.stopPropagation();
            });

            // ==========================================================
            // ===== NUOVA AGGIUNTA: RENDE L'IMMAGINE CLICCABILE ========
            // ==========================================================
            // Quando si clicca sull'immagine, simula un click sul link del pulsante play
            modalImage.addEventListener('click', () => {
                playLink.click();
            });
            // ==========================================================


            // Imposta il timer per la prima apparizione del popup
            popupTimer = setTimeout(showRandomVideoPopup, getRandomDelay(3, 8));


            // --- LOGICA BARRA DI PROSEGUIMENTO LETTURA ---
            // (Il codice per la barra di proseguimento che avevamo fatto prima va qui sotto)
            const articleBox = document.querySelector('.testo-articolo-sub-box');
            const progressBar = document.getElementById('reading-progress-bar');
            const footer = document.querySelector('footer');

            if (!articleBox || !progressBar || !footer) {
                console.warn("Elementi necessari per la barra di progresso non trovati.");
                return; // Esce dalla funzione se manca un elemento per evitare errori
            }

            const updateCustomProgressBar = () => {
                const articleRect = articleBox.getBoundingClientRect();
                const articleWidth = articleRect.width;
                const articleLeftOffset = articleRect.left;

                const footerPositionTop = footer.getBoundingClientRect().top + window.scrollY;
                const scrollEndPoint = footerPositionTop - window.innerHeight;

                const totalScrollDistance = scrollEndPoint;

                let progressFraction = 0;
                if (totalScrollDistance > 0) {
                    progressFraction = window.scrollY / totalScrollDistance;
                }

                const clampedProgress = Math.max(0, Math.min(progressFraction, 1));
                const currentBarWidth = articleWidth * clampedProgress;

                progressBar.style.left = `${articleLeftOffset}px`;
                progressBar.style.width = `${currentBarWidth}px`;
            };

            window.addEventListener('scroll', updateCustomProgressBar);
            window.addEventListener('resize', updateCustomProgressBar);
            updateCustomProgressBar();

        });
    </script><!--SCRIPT POPUP VIDEO-->
    <script>
        // 1. Prendo i riferimenti agli elementi necessari
        const scrollToTopBtn = document.getElementById("scrollToTopBtn");
        // Selezioniamo il footer in modo generico, senza bisogno di un ID
        const footer = document.querySelector("footer");

        // 2. Aggiungo l'ascoltatore all'evento di scroll
        window.onscroll = function() {
            scrollFunction();
        };

        // 3. Definisco la funzione che gestisce tutta la logica
        function scrollFunction() {
            // Logica di base per mostrare/nascondere il pulsante
            const isVisible = (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100);

            // Applica l'opacità in base alla visibilità
            scrollToTopBtn.style.opacity = isVisible ? "1" : "0";

            // --- NUOVA LOGICA PER LA POSIZIONE DINAMICA ---

            // Imposta una posizione di default per il 'bottom'
            let targetBottom = isVisible ? "3vmin" : "-5vmin";

            // Se il footer esiste sulla pagina, eseguiamo i calcoli
            if (footer) {
                // Calcoliamo 5vmin in pixel per poter fare somme corrette
                const vminInPx = Math.min(window.innerWidth, window.innerHeight) / 100;
                const gapInPx = 3 * vminInPx;

                // Calcoliamo la distanza tra il fondo della finestra (viewport) e il fondo del documento
                const distanceToDocBottom = document.documentElement.scrollHeight - window.scrollY - window.innerHeight;

                // La posizione in cui il pulsante deve "fermarsi" (altezza del footer + il gap desiderato)
                const stopPosition = footer.offsetHeight + gapInPx;

                // Se la finestra è entrata nella "zona del footer"
                if (distanceToDocBottom < stopPosition) {
                    // Calcoliamo dinamicamente il nuovo valore di 'bottom'.
                    // Sarà uguale alla distanza dal fondo del documento, mantenendo il gap.
                    const newBottomInPx = stopPosition - distanceToDocBottom;
                    targetBottom = `${newBottomInPx}px`;
                }
            }

            // Applica la posizione 'bottom' calcolata
            scrollToTopBtn.style.bottom = targetBottom;
        }

        // 4. Logica del click per tornare su (invariata)
        scrollToTopBtn.addEventListener("click", function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    </script><!--PULSANTE TORNA IN CIMA-->
	<script>
    document.addEventListener('DOMContentLoaded', function () {

        // --- SETUP DEGLI ELEMENTI DI LAYOUT ---
        const section1Container = document.querySelector('.section1-container');
        const placeholder = document.querySelector('.header-placeholder');
        const triggerBox = document.querySelector('.titolo-articolo-box');

        if (!section1Container || !placeholder || !triggerBox) return;

        // --- SETUP DEL TESTO E ANIMAZIONE (La tua logica re-integrata) ---
        const articleTitleText = document.querySelector('.titolo-articolo').textContent.trim();
        const marqueeSpans = document.querySelectorAll('.marquee');

        const originalMarqueeHTML = marqueeSpans.length > 0 ? marqueeSpans[0].innerHTML : '';
        const originalTextContent = marqueeSpans.length > 0 ? marqueeSpans[0].textContent.trim() : '';
        const textEndIndex = originalMarqueeHTML.indexOf(originalTextContent) + originalTextContent.length;
        const nbspSuffix = originalMarqueeHTML.substring(textEndIndex);
        const newMarqueeHTML = articleTitleText + nbspSuffix;

        const speedFactor = 0.18;
        const minDuration = 8;
        let newDuration = Math.max(minDuration, articleTitleText.length * speedFactor);
        newDuration = Math.round(newDuration * 10) / 10;
        // ---------------------------------------------------------------------

        // --- CALCOLI DI LAYOUT FATTI UNA SOLA VOLTA ---
        const containerHeight = section1Container.offsetHeight;
        const activationPoint = triggerBox.offsetTop;

        // --- GESTIONE DELLO STATO E DELLO SCROLL (OTTIMIZZATO) ---
        let isHeaderFixed = false;
        let lastScrollY = window.scrollY;
        let ticking = false;

        function updateHeaderState() {
            const currentScrollY = window.scrollY;
            const direction = currentScrollY > lastScrollY ? 'down' : 'up';

            // --- SEZIONE DI ATTIVAZIONE ---
            if (currentScrollY >= activationPoint) {
                if (!isHeaderFixed) {
                    isHeaderFixed = true;

                    placeholder.style.display = 'block';
                    placeholder.style.height = `${containerHeight}px`;
                    section1Container.classList.add('is-fixed');

                    // --- AGGIORNA IL CONTENUTO (La tua logica inserita qui) ---
                    marqueeSpans.forEach(span => {
                        span.innerHTML = newMarqueeHTML;
                        span.style.animationDuration = `${newDuration}s`;
                    });
                    // -----------------------------------------------------------

                    // Gestisce la transizione di apparizione
                    setTimeout(() => {
                        section1Container.style.top = '0';
                    }, 10);
                } else {
                    // Gestisci comparsa/scomparsa se già attivo
                    if (direction === 'down') {
                        section1Container.style.top = '0';
                    } else if (currentScrollY > activationPoint) {
                        section1Container.style.top = '-15vmin';
                    }
                }

                // --- SEZIONE DI DISATTIVAZIONE ---
            } else {
                if (isHeaderFixed) {
                    isHeaderFixed = false;

                    placeholder.style.display = 'none';
                    placeholder.style.height = '0';
                    section1Container.classList.remove('is-fixed');
                    section1Container.style.top = null;

                    // --- RIPRISTINA IL CONTENUTO (La tua logica inserita qui) ---
                    marqueeSpans.forEach(span => {
                        span.innerHTML = originalMarqueeHTML;
                        span.style.animationDuration = null;
                    });
                    // -------------------------------------------------------------
                }
            }

            lastScrollY = currentScrollY <= 0 ? 0 : currentScrollY;
            ticking = false;
        }

        // --- EVENT LISTENER OTTIMIZZATO ---
        window.addEventListener('scroll', function() {
            if (!ticking) {
                window.requestAnimationFrame(updateHeaderState);
                ticking = true;
            }
        }, { passive: true });
    });
</script><!--SCRIPT TENDINA-->
    <script>
        // Wait for the page content to be fully loaded before running the script
        document.addEventListener('DOMContentLoaded', function() {

            // 1. An array containing all your GIF links
            const gifUrls = [
                "https://images.squarespace-cdn.com/content/v1/525073c8e4b078f55072373d/1517526768399-J6GWOSF6JUXLKE22U3HV/coke_change.gif",
                "https://cdn.dribbble.com/userupload/14672696/file/original-2e8d4c9aa547c3d34636dfc94717cbdd.gif",
                "https://i.pinimg.com/originals/0b/28/8d/0b288dcaa37b56cd603b59ae7e8b4631.gif",
                "https://www.theispot.com/assets/images/source/ezgif1111111111111111111111111111111111111111111.gif",
                "https://www.allthingscommunicate.it/assets/media/blog/atc--all-things-communicate-premiata-allo-smart-retail-award-2023-per-il-progetto-issima-pokemon-in-collaborazione-con-levissima/pokemon-card-Influencer.gif",
                "https://www.quattroruote.it/news/novita/2017/06/29/fiat_500_anniversario_versione_speciale_per_celebrare_i_60_anni_del_cinquino/_jcr_content/content/article_gif/image.img.gif/1498751935460.gif",
                "https://media3.giphy.com/media/v1.Y2lkPTZjMDliOTUyM3p0bW4xMzJzajBodmpzNHhoY3FybzdqNThzeThtaDZ1OGE0azVqdSZlcD12MV9naWZzX3NlYXJjaCZjdD1n/4EHsAtAPcV41vx2B5s/source.gif",
                "https://i.pinimg.com/originals/d4/7f/5b/d47f5b6df925bf2b264862637f8988fa.gif",
                "https://m.media-amazon.com/images/G/31/img22/pcacc/logidays/Defy_Boring_Pebble_Keys_and_Pebble_Mouse_2_White_16x9_15s_en_MP4_1_1_1.gif",
                "https://api.time.com/wp-content/uploads/2023/07/TIME.com-Barbie-Partnership-copy.gif",
                "https://mir-s3-cdn-cf.behance.net/project_modules/source/bbcefb182626713.6530ea433e155.gif",
                "https://i.pinimg.com/originals/79/1c/aa/791caae6a49ae8228206006ebd2173e7.gif",
                "https://cdn.dribbble.com/userupload/21704245/file/original-7c30ea78f4fa32d5d82026b6d9f90b56.gif",
                "https://i.pinimg.com/originals/f7/df/8d/f7df8df7d039ab276deb048fd0938e72.gif"
            ];

            // 2. A function to shuffle an array (Fisher-Yates shuffle algorithm)
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                }
            }

            // 3. Select all the image elements that need a GIF
            // We use the class '.spazio-per-testo-con-oggetto-centro' which is on all your images
            const imageElements = document.querySelectorAll('.spazio-per-testo-con-oggetto-centro');

            // 4. Shuffle the array of GIF URLs
            shuffleArray(gifUrls);

            // 5. Assign each shuffled GIF to an image element
            imageElements.forEach((imgElement, index) => {
                // Check if there is a gifUrl for this image to avoid errors
                if (gifUrls[index]) {
                    imgElement.src = gifUrls[index];
                }
            });

        });
    </script><!--SCRIPT PUBBLICITÀ CENTRALE RANDOMIZZATA-->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const webpage = document.querySelector('.smuzn-webpage');
            const overlay = document.getElementById('t-rex-overlay');
            let isOverlayShown = false;
            let runnerInstance = null;

            if (!webpage || !overlay) {
                console.error("Elementi .smuzn-webpage o #t-rex-overlay non trovati.");
                return;
            }

            window.addEventListener('scroll', () => {
                if (isOverlayShown) return;

                const triggerPoint = webpage.offsetTop + (webpage.offsetHeight / 2);

                if (window.scrollY > triggerPoint) {
                    overlay.style.display = 'block';
                    document.body.style.overflow = 'hidden';
                    isOverlayShown = true;

                    // Inizializza il gioco del dinosauro una volta che l'overlay è visibile
                    if (!runnerInstance) {
                        runnerInstance = new Runner('#t-rex-overlay');
                    }
                }
            });
        });
    </script><!--SCRIPT ATTIVAZIONE POPUP T-REX CONNESSIONE CHIUSA-->
</div>
</body>
</html>